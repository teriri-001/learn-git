# RabbitMQ基础

## MQ（消息队列）

**简介**

* MQ，即消息队列，做消息队列的产品称之为消息中间件。
* 是典型的生产者消费者模型，即生产者向队列中生产消息，消费者从队列中获取消息。
* 消息的生产和消费都是异步的，而且各自只需要关心消息的生产和接收，所以实现了系统间的解耦合

**AMQP**

​	AMQP高级消息队列协议。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计![img](C:\Users\yangyim\Desktop\idea\RabbitMQ\20160310091724939)

AMQP协议重要概念：

* **server(broker)**：接收和分发消息的应用，如RabbitMQ 

* **Virtual host**：虚拟主机，出于多租户和安全因素设计的，一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。每一个vhost本质上是一个mini版的RabbitMQ服务器

* **Exchange**：交换器（路由），接收消息，按照路由规则将消息路由到一个或者多个队列

* **RoutingKey**：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。

* **Binding**：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个路由键

* **Queue**：消息队列，用来保存消息，供消费者消费。

* **Connection**：连接，生产者/消费者与RabbitMQ之间的TCP连接

* **Channel**：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。

  

connection中建立channel的原因：

​	 如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。



---

## RabbitMQ

RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的

**基础环境搭建**

* **linux系统下，安装rabbitMq及其Erlang依赖包**

* **编写rabbitma.config配置文件**

  * 可以使用提供的模板rabbitmq.config.example进行快速配置
  * 需要启动如下配置项：来宾配置![](C:\Users\yangyim\Pictures\snipaste\Snipaste_2020-09-21_11-24-08.jpg)

* **启动插件管理**

  ```shell
  # 执行如下命令
  rabbitmq-plugins enable rabbitmq_management
  
  # 启动rabbitmq
  systemctl start rabbitmq-server
  # 关闭
  systemctl stop rabbitmq-server
  # 运行状态
  systemctl status rabbitmq-server
  # 重启
  systemctl restart rabbitmq-server
  ```



---

## 消息模型

### 简单模式（直连、点对点）

![在这里插入图片描述](C:\Users\yangyim\Desktop\idea\RabbitMQ\20181221114009759.png)



**模式介绍**

* 生产者将消息放入队列
* 消费者监听消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除
* **隐患**： 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失
* **应用场景**：聊天



**引入依赖**

```xml
<!--引入rabbitmq依赖-->
<dependency>
     <groupId>com.rabbitmq</groupId>
     <artifactId>amqp-client</artifactId>
 </dependency>
```



**绑定虚拟主机**

* 在rabbitmq的web界面新建一个虚拟主机，虚拟主机相当于mysql中数据库的概念，一般一个项目创建一个虚拟主机
* 新建一个用户，授予权限，并绑定该虚拟主机



**生产者发布消息**

```Java
// 生产消息
public void sendMassage(){
    // 创建连接rabbitmq的连接对象，连接到具体的虚拟主机
    ConnectionFactory ctf = new ConnectionFactory();
    // 设置连接的主机ip
    ctf.setHost("xxxx.xxx.xx");
    // 设置端口号
    ctf.setPort(5672);
    // 设置连接的虚拟主机名称
    ctf.setVirtualHost("/xxx");
    //设置访问虚拟主机的用户和密码
    ctf.setUsername("xxx");
    ctf.setPassword("xxx");
    
    // 获取连接对象
    Connection connection = ctf.newConnection();
    
  	// 获取连接中的通道，通过通道绑定队列发送消息
    Channel channel = connection.createChannel();
    
    // 通道绑定消息队列
    /**
    * 函数参数:
    * 参数1: 消息队列名称，如果没有则自动创建一个
    * 参数2: 定义的这个队列是否要持久化，不持久化则在rabbitmq服务重启时消失。即使持久化，队列中消息也会消失，需要在发布消失时设置。
    * 参数3: 是否独占队列，即该队列是否只有当前的连接可用
    * 参数4: 是否在消费完成后自动删除队列
    * 参数5: 附加参数，null表示没有
    */
    channel.queueDeclare("hello",false,false,false,null);
    
    // 发布消息
    /** 
    * 函数参数:
    * 参数1: 交换机名称
    * 参数2: 消息队列名称
    * 参数3: 传递消息的额外设置，可以在该处设置队列消息的持久化
    * 参数4: 发布的消息,需要是字节类型的数据
 	*/
    channel.basicPublish("","hello",null,"hello,rabbitMq".getBytes());
    //关闭通道,感觉可以使用try finally包裹
    channel.close();
    // 关闭连接
    channel.close();
}
```



**消费者**

```Java
// 消费消息,需要连接到相同的虚拟主机、相同队列、相同信道
// 消费者一直处于监听状态
public class consumer{
    public void getMessage(){
    // 这部分连接的代码与生产者相同，可以封装成一个工具类 
    // ConnectionFactory属于重量级资源，避免重复创建，可以在工具类中单独封装一个静态代码块，类创建时便创建好，后续只需要调用即可
    ConnectionFactory ctf = new ConnectionFactory();
    ctf.setHost("xxxx.xxx.xx");
    ctf.setPort(5672);
    ctf.setVirtualHost("/xxx");
    ctf.setUsername("xxx");
    ctf.setPassword("xxx");
    Connection connection = ctf.newConnection();
        
    Channel channel = connection.createChannel();
    channel.queueDeclare("hello",false,false,false,null);
      
    // 消费消息
    /**
    * 参数1: 消费的队列名称
    * 参数2: 开启消息的自动确认机制
    * 参数3: 消费消息时的回调接口
    */
    channel.basicConsume("hello",true,new DefaultConsumer(cnl){
        @override
        // 拿到消息之后的回调函数
        public void handleDelivery(xxx,xxx,xxx,byte[] body){
            // body参数为消息队列中取出的消息
        }
    })
    // 正常情况下，消费者进程一直处于监听状态，有消息写入时便会进行接收
    // 可以手动关闭，当接收消息自动便关闭连接。但是不建议关闭
    channel.close();
    connection.close();   
    }
}
```

**工具类封装**

```Java
public class rabbitmqUtils{
    // 声明静态变量
    private static ConnectionFactory ctf;
    // 静态代码块,和静态变量执行顺序按代码书写先后
    // 变量赋值
    static{
        Conn = new ConnectionFactory
    }
    public static Connection getConnection(){
        //连接部分代码
    }
}
```



---

### 工作模式（多个消费者）

![在这里插入图片描述](C:\Users\yangyim\Desktop\idea\RabbitMQ\20181221114036231.png)

**模式介绍**

* 生产者将消息放入队列
* 消费者可以有多个,同时监听同一个队列，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息
* 默认情况下，多个消费者平均消费消息队列中的资源
* **隐患**：平均消费，会因为消费速度慢的消费拖垮消费速度。可以修改rabbitmq消息自动确认机制，改为能者多劳。
* **应用场景**：红包;大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲,直接将任务扔到消息队列中,空闲的系统自动争抢)



**生产者发布消息**

```java
// 发布消息的代码与简单模式一致，发布了多条信息
```



**消费者消费**

```Java
// 代码与简单模式一致
// 创建了多个消费者，平均消费消息

// 能者多劳模式
public class consumer{
    public void getMessage(){
        
        .....
            
    // 消费消息
    // 避免信道一次性全部分发，设置每一次只能消费一条消息
    cnl.basicQos(1);
    /**
    * 修改参数2: 开启消息的自动确认机制,自动确认即只要消息队列分发消息，不管有没有处理好，都自动确认完成，即欺骗消息队列已经消费了。从而让消息队列继续平均分发。能者多劳则需要关闭该功能，即为false
    */
    cnl.basicConsume("hello",false,new DefaultConsumer(cnl){
        @override
        public void handleDelivery(xxx,xxx,xxx,byte[] body){
            // body参数为消息队列中取出的消息
            // 开启手动确认,确认一条通道再发送一条
            /**
            * 参数1 ： 指定确认的是队列中的那一条消息
            * 参数2 ： 是否开启多个消息同时确认，因为通道中每一次只有一条，所以为false
            */
            cnl.basicAck(envelope.getDeliveryTag(),false);
        }
    })
    // 正常情况下，消费者进程一直处于监听状态，有消息写入时便会进行接收
    // 可以手动关闭，当接收消息自动便关闭连接。但是不建议关闭
    cnl.close();
    con.close();   
    }
}
```



---

### 广播模式（发布订阅）

![](C:\Users\yangyim\Pictures\snipaste\20181221114050657.png)



**模式介绍**

* 生产者产生消息后，消息被放入交换机中
* 由交换机决定把消息发送给绑定了交换机的消息队列中，让对应的消费者拿到消息进行消费
* 相关场景：邮件群发,群聊天,广播(广告)等共享资源



**生产者**

```java
// 获取连接后，创建通道，并将通道绑定交换机之后，发布消息，最后释放资源
public class provider{
    //获取连接对象
    .....
    // 获取生产者到交换机的信道
    Channel channel = connection.createChannel();
    
    // 通道绑定交换机
    /**
    * 参数1：交换机名称，没有则创建一个
    * 参数2：交换机的类型，广播模式固定为:"fanout"
    */
    channel.exchangeDeclare("myexchange","fanout");
    
    // 发布消息
    /**
    * 参数1：交换机名称
    * 参数2：路由键，在广播模式中没有意义
    * 参数3：额外设置
    * 参数4：发送的消息
    */
    channel.basicPublish("myexchange","",null,"my message");
    
    // 释放资源，关闭连接和通道
    .....
}
```



**消费者**

```Java
// 创建连接，和信道。将信道绑定交换机之后，建立临时队列（确定之后自动删除队列），消费消息，最后释放资源
public class consumer{
    public static void main(String[] args){
    	//获取连接对象
    	.....
    	// 拿到通道对象
    	Channel channel = connection.createChannel();
    	    
    	//通道绑定交换机
    	channel.exchangeDeclare("myexchange","fanout");
    	
        // 创建临时队列
        String tmpQueue = channel.queueDeclare.getQueue();
        
        // 绑定队列和交换机
        /**
        * 参数1：临时队列
        * 参数2：交换机
        * 参数3：路由键，广播模式中没有意义
        */
        channel.queueBind(temQueue,"myexchange","");
        
        // 消费消息
        channel.basicConsume(temQueue,true,new DefaultConsumer(channel){
           @override
           public void handleDelivery(xxx,xxx,xxx,byte[] body){
            system.out.println("消费了一条消息")
        })
    }
}
```



---

### 路由模式（direct）

![](C:\Users\yangyim\Pictures\snipaste\20181221114420299.png)



**模式简介**

* 消息发送消息给交换机时，需要指定消息的`routingKey(路由键)`

* 消息队列与交换机绑定时，也需要指定一个`routingKey`

* 交换机按照生产者指定的路由键进行匹配，即只有消费者指定的路由键相同时，交换机才会将消息发送到对应的消息队列中

* 一个消息队列可以指定多个`路由key`

  

**生产者**

```Java
//
public class provider{
    public static void main(String[] args){
        // 获取连接对象、获取信道对象
        ....
        
        // 通道绑定交换机,路由模式的交换机类型为：direct类型
        channel.exchangeDeclare("myexchange","direct");    
        
       	/**
       	* 发送消息
       	*/
        // 声明一个路由键
        String routingKey = "myroutingkey";
        // 发送消息
        channel.basicPublish("myexchange",routingKey,null,"send a message".getBytes());
        
        // 释放资源
        ......
    }
}
```



**消费者**

```Java
// 添加了绑定路由键的步骤
public class consumer{
    public static void main(String[] args){
        // 创建连接对象、信道对象
        ...
            
        // 通道声明一个交换机并绑定
        channel.exchangeDeclare("myexchange","direct");
        
        // 创建一个临时对立
        String temQueue = channnel.queueDeclare().getQueue();
        
        // 基于路由键绑定交换机和信息队列,参数3为路由键，需要与要接收的生产者相同
        // 可以使用多条绑定语句绑定多个路由键
        channel.queueBind(temQueue,"myexchange","myroutingkey");
        
        // 消费消息
        channel.basicConsume(temQueue,true,new DefaultConsumer(channel){
           @override
           public void handleDelivery(xxx,xxx,xxx,byte[] body){
            system.out.println("消费了一条消息")
        })
               
        // 释放资源
           ......    
    }
}
```



---

### 动态路由模式（Topic）

![](C:\Users\yangyim\Pictures\snipaste\20181221114420299.png)

**模式简介**

* 相较于路由模式，消费者在路由绑定时增加了用通配符的模糊查询方式



**路由键**

```bash
# 路由键设置
 	- 一般多个单词的路由键，要求使用'.'分隔，如：'hello.world'
 
# 通配符
	- '#' : 代表多个"单词"
	- '*' : 指代一个"单词"
```

