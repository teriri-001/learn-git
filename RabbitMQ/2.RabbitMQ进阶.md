## springboot整合rabbitMQ

### 环境搭建

**引入依赖**

```xml
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>

<!-- 创建项目异常时：
	右键pom.xml，选中“将其作为maven”项目即可
-->
```



**配置文件**

```yaml
# 项目名字，微服务中才有用
spring:
 application:
  name: rabbitmq-test 
# 配置连接
 rabbitmq:
  host: ip地址
  port: 端口号（5672）
  username: name
  password: xxxx
  virtual-host: 虚拟主机
```



**使用介绍**

​	springboot提供了一个模板对象：`RabbitTemplate`，用于简化操作rabbitmq，使用时直接在项目中自动注入即可



---

### 简单模式

**生产者**

```Java
public class provider{
    // 自动注入rabbitTemplate
    @Autowrited
    RabbitTemplate rabbitTemplate;
    
    // 生产方法
    public void sendmessage(){
        /**
        * 功能：自动将发送信息转换为Byte类型并发送
        * 参数1：已存在消息队列名称，需要由消费者创建
        * 参数2：发送的消息对象
        */
        rabbitTemplate.convertAndSend("hello","send a message by simple");
    }
}
```



**消费者**

```Java
@Component
// 初次可以使用如下方式声明为消费者，并创建一个队列
// 队列的设置可以使用@queue注解中的各种属性设置
// @queue默认创建的队列是：持久化、不独占、不是自动删除的
@RabbitListener(queueToDeclare = @Queue(value="myQueue"))
public class Consumer{
    // 获取到信息之后的回调函数
    @RabbitHandler
    public void myhandler(String massage){
        system.out.println("get a message"+message);
    }
}
```



---

### 工作模式

**生产者**

```Java
// 与前者没有变动
public class provider{
    // 自动注入rabbitTemplate
    @Autowrited
    RabbitTemplate rabbitTemplate;
    
    // 生产方法
    public void sendmessage(){
        /**
        * 功能：自动将发送信息转换为Byte类型并发送
        * 参数1：已存在消息队列名称，需要由消费者创建
        * 参数2：发送的消息对象
        */
        rabbitTemplate.convertAndSend("myqueue","send a message by work");
    }
}
```



**消费者**

```Java
// 公平分发模式
@Component
public class consumer{
    
    //@RabbitListener可以标注在方法上，表示该方法处理回调函数
    @RabbitListener(queues="myqueue")
    public void getmessage1(String message){
        // message是从队列中获取的消息
    }
    
    // 第二个消费者
    @RabbitListener(queues="myqueue")
    public void getmessage2(String message){
        //第二个处理逻辑
    }
}

// 能者多劳模式
```



---

### 广播模式

**生产者**

```Java
// 发布消息的函数不变，参数改变
public class provider{
    // 自动注入rabbitTemplate
    @Autowrited
    RabbitTemplate rabbitTemplate;
    
    // 生产方法
    public void sendmessage(){
        /**
        * 功能：自动将发送信息转换为Byte类型并发送
        * 参数1：交换机名称，由消费者创建
        * 参数2：路由键，广播模式无意义
        * 参数3：发送的消息对象
        */
        rabbitTemplate.convertAndSend("myexchange","","send by fanout");
    }
}
```



**消费者**

```Java
// 消费者
public class consumer{
    // 第一个消费者
    @RabbitListener(
        // 绑定交换机和消息队列
        @QueueBinding(
            value = @Queue, // 该注解未赋值表示创建一个临时队列
            // 创建一个交换机，并绑定
            exchange = @Exchange(value="myexchange",type="fanout")
         )
    )
    public void getmessage1(String msg){
        // 获取信息的回调函数体
    }
    
    // 第二个消费者
    ......
    
}
```



---

### 路由模式

**生产者**

```Java
// 与广播模式的生产者基本一致，发送消息时增加了路由键，同样由消费者创建
public class provider{
    public void sendmessage(){
        rabbitmqTemplate.convertAndSend("myexchange","myroutingkey","send message by route")
    }
}
```



**消费者**

```java
// 在广播模式基础上添加路由
public class consumer{
    // 第一个消费者
     @RabbitListener(
          @QueueBinding(
              value = @Queue,
              exchange = @Exchange(value="myexchange",type="direct")
              // 指定路由键,可以指定多个
              key = {"myroutingkey","xxx","xxxx"}
          )
     )
    public void getmessage1(String msg){
        // 获取消息后的回调函数的函数体
    }
}
```



**动态路由**

* 修改交换机类型
* 注意路由键的名称
* 使用通配符