## 基础查询语言
1. 语法
    * `select 查询列表 form 表名`
    * 查询列表
        1. 表中的字段
        2. 常量值
        3. 表达式
        4. 函数
    
2. 查询表中字段
    * `select 字段名 from 表名`,多个字段用逗号隔开
    * 所有字段用通配符`\*`表示，不足在于将按表中顺序显示
    * 对于大写的字段，为了区别于关键字，可以使用单引号标识

3. 查询常量值、表达式、函数
    * 使用`select  常量/表达式/函数`进行查询，返回的字段名为查询值，返回值为计算结果。
    * 查询常量时，返回常量
    * 查询表达式时，返回表达式结果
    * 查询函数，返回函数结果（如查询now(),则返回当前时间）

4. 为查询结果取别名
    * 用途
        1. 用于更改返回的字段名，便于理解；
        2. 如果查询结果有重名的情况，可以便于区分。
    * 方法：
        1. 使用`select ... as 别名 from 表名`语句进行更改
        2. 直接在查询字段后用空格标出：`select 字段名 别名 from 表名`
        3. 别名中有特殊字符如空格时，需要使用单引号将别名标记

5. 去重
    * 去除查询结果中重复出现的值，让其只输入一个。
    * 在字段名前加入关键字：`distinct`

6. '+'号的作用
    * 在MySQL中`+`号只能作为运算符，不能用于字符连接
    * MySQL中的字符连接，需要使用函数：`concat(str,str,....)`
    * 当字符连接的一方为null,则结果为null

7. 查询表中数据条数
    * 使用`select count(字段) form 表名`

8. 替换表中数据为空的函数
    * `ifnull(str1,str2)`:
        1. str1为可能为空的字段名
        2. str2是字段为空后的替换值

9. 判断表中数据是否为空的函数：`isnull(字段名)`

10. 判断字段值长度函数：`length(字段名)`

## 条件查询
1. 语法
    * 在基础查询的语句上，使用`where`添加查询条件
    * 基础查询返回字段所有行，条件查询只返回符合条件的值

2. 执行逻辑
    1. 先执行from，确定数据库中是否存在该表
    2. 再执行筛选条件，找到满足条件的数据行
    3. 最后检查查询列表，输出相应字段

3. 条件查询分类
    1. 类型一：按条件表达式筛选
        * 条件运算符：`> , < , = , != , >= , <=`
        * 不能用于判断`null`值，只能使用模糊查询语句
    2. 类型二：按逻辑运算符查询
        * 逻辑运算符：`and , or , not 或 (&&,||,!)`
    3. 类型三：模糊查询
        * `like , between and ,in ,is null`

4. mysql通配符
    * `%`: 用来表示多个任意字符，包含0个
    * `_`：用来表示一个任意字符（即可以是a,可以是b)
    * `escape`:用来指定某一字符具有转义功能，也可以直接使用'\\'
        1. '_$_%' escape '$' ---指定$为转义字符
    * 通配符一般和模糊查询关键字like结合使用
## 模糊查询（条件查询类型三）
* 应用于查询条件很模糊的情况（如包含、在..之间

1. `like`关键字：（包含） 
    1. 查询员工名字中`包含字母a`的员工信息
    ```
    select 
        *
    from 
        employees
    where
    # 通配符 % 表示多个任意字符
        last_name like '%a%';
    ```
2.  `between and`关键字：（在...之间）
    1. 格式：`between a and b`，表示在a和b之间（包含a,b)，顺序不能颠倒
    2. 可以提高语句简洁度

3. `in`关键字：（属于）
    * 判断某字段的值是否属于in列表中的某一项
    * 提高语句简洁度
    * 使用示例：`where job_id in('ad_vp','it_prot')`返回job_id值等于其中一项的行。
    * 不能结合通配符使用

4. `is null`关键字：（null值判断）
    * 用于判断字段值是否为null，因为条件运算符无法判断
    * 判断不为null，可以使用语句：`is not null`

5. 安全等于：`<=>`
    * 可以用于判断null值，作为等于判断符
    * 可读性低，少有人用
6. 模糊查询语句可以结合not逻辑运算符使用

## 排序查询
* 将返回的结果按照一定条件进行排序显示

1. 语法：
    * 在原始查询语句的基础上，在末尾添加`order by`语句
    * `asc`：升序排序，默认值
    * `desc`：降序排序
    * 排序查询可以支持`表达式、别名、函数、多个字段`等；

2. 按多个字段排序
    * 可以使用一个order by语句对多个字段进行排序，使用逗号分隔字段；
    * 越前面的字段，排序优先级越高；

## 常用函数简介
1. 函数分类
    * 单行函数：常做数据处理
    * 分组函数：常做统计使用，又称为统计函数、聚合函数

2. 单行函数分类
    * 字符函数
    * 数学函数
    * 日期函数
    * 流程控制函数等

## 单行函数
1. 字符函数
    * `length(字符)`:返回参数值的字节个数
    * `concat(a,b,...)`:拼接字符
    * `upper、lower()`：大小写转换
    * `substring()`:截取字符串，有两种重载函数
        1. `(str,index)`:截取指定位置之后的字符，起始索引为1（不是0）
        2. `(str,index,lenth)`:截取指定位置之后指定字符长度的字符
    * `instring()`:返回子串在父串中第一次出现的起始位置
    * `trim('a' from 'str')`:取出字符前后空格或指定(一个或多个)字符
    * `lpad、rpad('str',length,'pad')`：使用字符将目标字符串左（右）填充至指定长度，目标字符过长会进行截断
    * `replace('str','old','new')`：字符串替换

2. 数学函数
    * `round()`：四舍五入，有两种重载
        1. `round(num)`：四舍五入
        2. `round(num,length):四舍五入后保留指定小数点后位数
    * `ceil()、floor()`：向上取整,向下取整
    * `truncate(num,length)`：小数保留指定位数
    * `mod(a,b)`：对a/b取余

3. 日期函数
    * 日期格式：`%Y-%m-%d`
    * `now()`：返回当前系统日期和时间
    * `curdate()，curtime()`：返回日期,返回时间
    * 返回日期的指定部分：`日期单词(日期)` 
        1. 举例：`year('2020-08-10')`
    * `str_to_date()`：将字符转换为指定格式的日期类型
        1. 举例：`select str_to_date('2020-8-10','%Y-%m-%d');`
    * `date_format()`:将日期转换成字符类型
        1. 举例：`select date_format(now(),'%Y年-%m月-%d日');`
    * `datediff(dat1,dat2)`：计算前后日期之差

4. 流程控制函数
    * if函数：条件控制if else效果
        1. 举例：`select last_name,commission_pct,if(commission_pct is null,'没奖金','有奖金') as 备注`
    * case函数
        1. switch case 的效果：
        ```
        case 要判断的字段或表达式
        when 常量 then 要执行的语句；
        when 常量 then 要执行的语句；
        。。。。
        else 默认情况，相当于default；
        end 结束标志
        ```
        2. 多重if的效果
        ```
        case
        when 条件1 then 结果为真执行的语句
        when 条件2 then 结果为真执行的语句
        。。。。
        else 都不为真执行语句
        end 结束标志
        ```
        3. 使用示例
        ```
        select last_name,salary,
        case
        when salary>20000 then 'a'
        when salary>15000 then 'b'
        when salary>10000 then 'c'
        else 'd'
        end as 等级
        from employees;
        ```

## 分组函数（聚合函数）
1. 常见函数
    * `sum()`
        1. 求和，忽略null
        2. 只支持数值参数
    * `avg()`
        1. 平均值，忽略null
        2. 只支持数值参数
    * `max()、min()`
        1. 最大最小值，忽略null
        2. 支持字符型参数（能进行排序）
    * `count()`
        1. 统计个数，忽略null
        2. 支持任何类型参数

2. 进阶使用
    * 配合distinct搭配去重
        1. 示例 `count(distinct salary)`
    * `count()`使用
        1. 统计行数：`select count(*) from tables`
    * 和分组函数一同查询的字段要求是`group by`后的字段

## 分组查询
1. 概述
    * 使用`group by`语句将表中的数据分成若干组
    * `要求查询列表，必须是分组函数或者是group by后出现的分组条件`

2. `having`关键字
    * 对分组后的结果表进行查询（不是对原始表的操作）
    * 案例1：查询员工个数大于2的部门
    ```
    /* 1 在原始表的基础上统计每个部门的员工个数，产生分组后的表
       2 在分组后的结果之上，筛选员工数大于二的情况
    */
    select department_id,count(*) as number
    from employees
    # where number>2,此处使用where查询的是原始表，没有该字段，无法查询
    group by department_id
    having number>2;
    ```

3. 小总结
    * 筛选条件按数据源分类
        1. 分组前筛选
        2. 分组后筛选
    * 分组前删选
        1. 数据源为原始表
        2. 筛选语句放在group by之前，使用where关键字
    * 分组后删选
        1. 数据源为分组后的结果集
        2. 筛选语句放在group by之后，使用having关键字
    * 特点
        1. 分组函数结果做条件一定是分组后筛选
        2. 能用分组前筛选一定要用分组前筛选

4. 分组条件总结
    * 可以使用`字段、表达式、函数等`作为分组条件
    * 按多个字段分组
        1. 将多个字段都放在group by之后，中间用逗号隔开

5. 添加排序
    * 分组查询支持排序操作，需要放在末尾

## 连接查询
1. 概述
    * 连接查询又称多表查询
    * 当查询的字段涉及多个表时，使用多表查询
    * 笛卡尔乘积现象：
        1. 表一有m行，表二有n行，结果出现n*m行
        2. 原因是查询时没有添加有效的连接条件，则表一中的一行对应表二中的每一行都有效。
        3. 避免方法：有效连接条件，两表连接时，相同字段需要使用表名限定

2. 连接查询分类
    * 按年代分类
        1. sql92标准
            * 只支持内连接
        2. sql99标准（推荐）
            * 支持内连接+外连接（全外连接除外）+交叉连接
    * 按功能分类
        * 内连接（主要用于查询表的交集部分）
            1. 等值连接
            2. 非等值连接
            3. 自连接
        * 外连接（主要用于查询两表交集外的部分）
            1. 左外连接
            2. 右外连接
            3. 全外连接
        * 交叉连接

### SQL92标准
1. 等值连接
    * 让表一中的数据在表二中依次比较，返回相等结果
    * 为了便利书写，可以为表取别名，格式与字段别名一致，注意取别名后必须使用别名指代表 
    * 添加筛选条件：可以在where后面添加筛选条件
    * 可以添加分组，排序等
    * 多表连接
        1. 格式与两个表连接一致，注意连接条件
        2. n表连接，至少需要n-1个连接条件

2. 非等值连接
    * 在等值连接的基础上，让连接条件不再是值相等
    ```
    #案例：查询员工的工资和工资级别
    select salary,grade_level
    from employees e,job_grades j
    where salary between j.lowest_sal and highest_sal;
    ```

3. 自连接
    * 与等值连接思路一致，区别在于将本表当作两张表或多张表使用
    * 需要使用别名进行表的区分

### SQL99标准（建议使用）
1. 连接方式
    ```
    select 查询列表
    from 表1 别名 
    [连接类型] join 表2 别名
    on 连接条件
    [where 筛选条件]
    ```
2. 连接类型（内连接、外连接等）关键字
    * 内连接：`inner`;
    * 外连接：`left[outer]`,`right[outer]`;
    * 交叉连接：`corss`

3. 内连接
    * 内连接的思路和特点都与前面相同，区别只是写法不同
    * 多表连接注意：
        1. 连接条件紧跟在表后面，连接完一个再连接下一个。
        2. 表与表之间保持连接条件

4. 外连接
    * 思路：
        1. 将本表作为主表，连接的表作为从表
        2. 主表中的数据，与从表中的每一条数据比对，相等则返回对应值，不相等则返回null
    * 注意事项
        1. 内连接结果+主表中有而从表中没有的记录
        2. 主从表不能交换（因为最终显示的是主表中的所有数据）
        3. 所查询的信息主要来自那个表，则那个表便为主表
    * 左外连接
        1. left左边的为主表
    * 右外连接
        1. right右边的是主表
    * 全外连接
        1. 内连接结果+主表有从表没有+从表有主表没有
        2. MySQL不支持

5. 交叉连接
    * 思路
        1. 多个表的笛卡尔乘积
        2. 使用关键字cross join

## 子查询
### 子查询概述
1. 概述
    * 出现在其他语句中的select语句，称为子查询或内查询，被嵌套的select语句称为外查询或主查询

2. 分类
    * 按子查询出现的位置
        1. select后面
            * 仅支持标量子查询
        2. from后面
            * 支持表子查询
        3. where或having后面（重点）
            * 支持标量子查询（单行）
            * 行、列子查询（多行）
        4. exists后面（相关子查询）
            * 表子查询
    * 按结果集的行列数不同
        1. 标量子查询：结果集只有一列一行
        2. 列子查询：结果集只有一列多行
        3. 行子查询：结果集有一行多列
        4. 表子查询：结果集为表（一般多行多列）

3. 特点
    * 子查询放在小括号中
    * 子查询一般放在条件的右侧
    * 标量子查询一般搭配着单行操作符使用（条件运算符）
    * 列子查询一般搭配多行操作符使用（in，any/some，all)

### where和having后面的子查询
1. 标量子查询（单行）
    * 子查询先于主查询执行，需要利用子查询返回的结果
    * 非法使用情况
        1. 返回结果不是一个值（单行单列）
        2. 返回结果为null
    * 使用举例
    ```
    // 查询最低工资大于50号部门最低工资的部门id和其最低工资
    // 后找出所有部门的最低工资并与子查询返回结果比较
    SELECT department_id,min(salary)
    FROM employees
    GROUP BY department_id
    HAVING min(salary)>(
        // 先查询50号部门的最低工资
        SELECT min(salary)
        FROM employees
        WHERE department_id=50
    );
    ```

2. 列子查询（多行）
    * 需要搭配多行操作符使用
    * 多行操作符
        1. `in/not in`：等于列表中(子查询返回结果)的任意一个
        2. any|some：和子查询返回的某一个值比较，可以被替代
        3. all：和子查询返回的所有值值比较，可以被替代

### select后面的子查询
1. 适用场景
    * 存在两个表，a和b，需要返回a表中的所有字段，同时还需要对b表中关联字段计算后返回，此时使用子查询查询b中的字段，主查询中再查询a表信息及子查询返回的b表信息标量
    * 示例
    ```
    // 查询每个部门的所有信息，及员工个数
    SELECT d.*,(
        SELECT COUNT(*)
        FROM employees
        WHERE employees.`department_id`=d.department_id
    )
    FROM departments d;
    // 使用分组无法返回所有信息，使用多表查询无法统计员工个数
    ```

### from后面的子查询
1. 特点
    * 子查询返回结果集为一个表，主查询需要在该表之上进行操作

2. 使用流程
    1. 子查询返回一个新表，为该表取一个别名，后续使用的字段也需要取别名，防止歧义
    2. 使用多表查询操作进行表连接并查询结果

3. 使用案例
    ```
    // 查询每个部门的平均工资的工资等级
    /*
    1. 子查询返回部门平均工资表,并取一个别名
    2. 使用多表查询，查询结果
    SELECT av_dep.*,j.grade_level
    from (
        SELECT avg(salary) av
        from employees
        GROUP BY department_id
    ) av_dep
    INNER JOIN job_grades j
    ON av_dep.av BETWEEN j.lowest_sal AND j.highest_sal;
    ```

### exits后面的子查询（相关子查询）  
1. exits关键字
    * 检查一个子查询是否至少会返回一行数据，返回值为true或false

2. 语法
    * `exists subquery`：subquery是一个受限的select语句（不允许有compute子句和into关键字）
    * subquer子查询语句返回的是一个结果集

3. 特点
    * exits子查询结果作为主查询返回数据的判断
    * exits子查询可以被其他方法替代（如使用in的多行子查询）

## 分页查询
1. 应用场景
    * 当要显示的数据量太大，一页显示不全，则需要进行分页提交SQL请求或取限制数量的数据

2. 语法
    * 使用关键字`limit offset,size`进行限制
    * `offset`：起始索引，从0开始计数
    * `size`：要显示的条目

3. 特点
    * limit语句放在查询语句的最后
    * 常用公式`(page-1)*size`
        1. page：要显示的页数
        2. size：每页的条目数

4. 应用示例
    ```
    // 查询平均工资最高的部门编号
    SELECT department_id
    FROM employees
    GROUP BY department_id
    ORDER BY avg(salary)
    LIMIT 1;
    ```

## 联合查询
1. `union`关键字
    * 联合，合并。即将多条查询语句的查询结果合并成一个结果

2. 语法
    * 使用`union`联合多个查询语句，最后的返回结果为多个结果的`或(or)`

3. 应用场景
    * 当所需的查询结果涉及多个表，且没有直接的关联，但是查询的信息一致。则可使用联合查询合并各个表的查询结果

4. 注意事项
    * 联合查询中各个查询语句涉及的列数必须保持一致
    * 尽量使多条查询语句之间对应的返回数据类型，顺序保持一致
    * 联合查询的结果默认去重，可以使用`union all`保留重复项
    * 查询结果的字段名默认为第一条查询语句的字段名