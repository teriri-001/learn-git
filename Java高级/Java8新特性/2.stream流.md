# stream流

1. 特点
   
   * jdk8新特性，允许以声明方式处理数据集合
   
2. 使用流程
   1. 将集合转化为stream流
      * 方法一：==集合.stream()==
      * 方法二：==集合.parallelStream()==创建一个多线程的stream流
   2. 操作stream流
      * stream流在管道中经过==中间操作==的处理，最终由==最终操作==得到前面处理的结果
      * 因为中间操作返回的结果还是一个流，需要最终操作转换它的数据类型
   
3. 操作符
   1. 中间操作符

      *  ==filter==：过滤集合中不符合条件的元素，并返回符合条件元素的集合

        ```java
        list<String> str = Arrays.aslist("abc","bb","bc","acf","bc");
        // 将str转换为stream流，将包含字母f的返回，返回类型转换为list集合
        list<String> fiters = str.stream().filter(elm -> str.contains("f").collect(collectors.tolist()));
        ```

      * ==distinct==：去除集合中的重复元素，基于流生成对象的==hashcode()==和==equals==方法实现

        ```java 
        // 去除str集合中的重复元素
        list<string> distincts = str.stream().distinct().collect(collectiors.tolist());
        ```

      * ==limit==：返回集合中指定个数的元素

        * ```java
          list<string> limits = str.stream().limit(3);
          ```

      * ==skip==：与limit相反，它的作用在于剔除集合前指定个数的元素

        * ```java
          list<string> skips = str.stream().skip(2);
          ```

      * ==map==：对集合转换后的流中所有元素统一进行处理，需要`return`返回一个值

        ```java
        // 可以使用一个函数作为处理参数
        // 例子：将元素添加后缀test_
        list<string> maps = str.stream().map(elm -> elm.contact("test_").collect(collectors.tolist()));
        ```

      *  ==peek==：对集合转换流中所有元素统一进行处理，不需要使用`return`返回一个值

      * ==flatmap==
   
     * 与map作用一致，都是对流中所有元素进行统一处理
        
* 区别在于，flatmap添加了一个扁平化处理，即相同的元素类型不是返回多个结果，而是统一到一个结果中返回
        
      * ==sorted==：对集合中的元素进行排序，可以使用默认方法排序，也可以传入比较器进行排序
   
        ```java
       list<string> sorteds = str.stream().sorted(可以传入比较器)
     ```
   
2. 终止操作符
   
      * ==anymatch==：检查集合中是否==存在一个==元素满足条件，返回布尔值
   
        ```java
       boolean anymatchs = str.stream().anyMatch(elm -> elm.contains("bc"));
     ```
   
      * ==allmatch==：检查集合中是否==所有的==的元素都满足条件，返回布尔值
   
        ```java
       boolean allmatchs = str.stream().allmatch(elm -> elm.leanth() > 1);
     ```
   
      * ==nonematch==：检查集合中是否所有的元素都==不满足==条件，返回布尔值
   
        ```java
       boolean nonematchs = str.stream().nonematch(elm -> elm.leanth() > 5);
     ```
   
   * ==findany==：返回集合中任意的一个元素（单线程的stream一般为第一个），返回类型为optional类型
   
        * optional类型：Optional 类是一个==可以为null==的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象
   
          ```java
          optional<string> findanys = str.stream().findany();
          //对于optional类型的元素使用时需要先进行非空判断
          if(findanys.ispresent())
              // 对象类型，获取值需要对外提供的get、set方法
           system.out.printIn(findanys.get())
       ```
   
   * ==findfirst==：返回集合中的第一个元素，返回类型为optional类型的对象
   
      * ==foreach==：循环遍历集合中的元素，效率高于外部循环
   
        ```java
        // 相较于map,区别在于map有返回值
        str.stream().forEach(elm -> system.out.print(elm))
        ```
        
      * ==orElse()==：当optional值存在时，返回optional的值，否则返回该方法设置的默认值
  ```Java
      
* ==collect==：主要用于将stream流转换为其他类型：list、set、map
      
        ```java
        // 转set集合
        set<string> collect1 = str.stream().collect(collectors.toset());
        // 转map集合，需要自己设置键值对,同时需要处理遇到重复元素时的选择问题
        // 参数：key,value,重复处理
        map<string> collect2 = str.stream().collect(collectors.tomap(k -> "key_"+k,v -> "value_"+v,(oldvalue,newvalue) -> newvalue));
  ```

~~~Java
  * ==reduce==：将stream流中的元素通过一些函数结合起来，返回一个结果
  
    ```java
    // 对集合中的元素进行累加
    optional<string> reduces  = str.stream().reduce((前面返回的结果acc，str中的下一个对象item) -> {return 结合方式acc+item;});
    ```
  
  * ==count==：计数，返回集合中元素的个数
~~~
