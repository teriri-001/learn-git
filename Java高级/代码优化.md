### 代码优化

##### (1) 尽量指定类、方法的final修饰符

* 将类用`final`修饰符修饰可以让该类不能被继承；为方法指定`final`修饰符可以让方法不能被重写
* 如果指定一个类为`final`，则该类的方法都是`final`的。**Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率左右重大**



---

##### (2) 尽量重用对象

* 生成对象、以及对这些对象进行垃圾回收等处理都需要花费Java虚拟机的时间



---

##### (3) 尽可能使用局部变量

* 局部变量（临时变量）都保存在栈中，速度较快，随着方法运行结束，这些内容就没了，不需要额外的垃圾回收



---

##### (4) 及时关闭流

* 进行数据库连接、I/O流操作时，使用完毕之后，及时关闭以释放资源



---

##### (5) 尽量减少对变量的重复计算

* 任何操作多少都是有消耗的，如下操作：

```Java
for (int i = 0; i < list.size(); i++)
{
    ......
}
```

​	建议替换为：

```java
for (int i = 0; length = list.size(); i < length; i++)
{
	......
}
```



---

##### (6) 尽量采用懒加载的策略，即在需要的时候才创建

```java
String str = "aaa";
if (i == 1)
{
   list.add(str); 
}
```

可以替换为：

```java
if (i == 1)
{
    String str = "aaa";
    list.add(str);
}
```



---

##### (7) 谨慎使用异常

* 异常对性能不利。异常只能用于错误处理，不应该用于程序流程控制



---

##### (8) 循环和`try catch`的位置问题：(遇到异常时)

* try放在循环内部，抛出异常后继续执行
* try放在循环外部，抛出异常后，中断循环



---

##### (9) 如果能估计到所需内容长度，建议为底层以数组方式实现的集合指定初始容量

* 如`arrayList`、`StringBuilder`、`LinkedList`、`hashMap`、`hashSet`等
* 该类的机制是，当存入的值到达其最大容量时，它会成倍的扩充本身容量。从而耗费性能
* 需要注意`HashMap`的初始容量设置



---

##### (10) 复制数组时，最好使用`system.arraycopy()`

```java
char[] chars = {'c','h','i','n','a'};
char[] chars1 = new char[chars.length];
// 将chars中的数据，从0开始复制到chars1中，并从0开始放置，复制长度为chars.length
System.arraycopy(chars,0,chars1,0,chars.length);
```



---

##### (11) 循环内部不要不断创建对象引用

示例如下：

```java
for (int i = 0; i <= count; i++)
{
    // 这是两步操作
    Object obj = new Object();
}
```

上述方法，在每次循环时，都会创建一份Object对象的引用，比较耗费内存。可替换为：

```java
Object obj = null;
for (int i = 0; i <= count; i++)
{
    obj = new Object();
}
```



---

##### (12) 基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用arrayList



---

##### (13) 尽量使用线程不同步的：`hashmap` `arraylist` `stringBuilder`



---

##### (14) 尽量在合适的场合使用单例模式

使用单例模式可以减轻加载的负担、缩短加载的时间、提高加载的效率。适用场景如下：

* 控制资源的使用
* 控制实例的产生
* 控制数据的共享



---

##### (15) 尽量避免随意使用静态变量

当某个对象被定义为static的变量所引用，那么gc（垃圾回收机制）通常是不会回收这个对象所占有的堆内存的



---

##### (16) 及时清除不再需要的会话



---

##### (17) 遍历实现RandomAccess接口的集合：（改：底层实现为数组等有序结构使用普通for，而使用链表等结构使用增强for）

* 如`ArrayList`
* 应当使用最普通的for循环，而不是foreach(增强for循环)
* 反之，使用foreach的效率更高,其底层为迭代器实现



---

##### (18) 使用同步代码块替代同步方法

* 同步方法中存在一些不需要同步的操作，而真正需要同步的是对共享资源的操作



---

##### (19) 程序运行过程中避免使用反射

* 反射功能强大，但是效率不高。
* 必要时，建议将需要通过反射操作的类，在项目启动时通过反射将其实例化，放入内存中。从而以牺牲程序加载效率而保持响应效率



---

##### (20) 使用数据库连接池、和线程池



---

##### (21) 使用带缓冲区的输入输出流进行I/O操作(如bufferedReader)

* 缓冲区操作是在缓冲区满，或者接收到指令时才进行一次I/O操作
* 不带缓冲区时，会实时进行I/O操作，影响性能。



---

##### (22) ArrayList和LinkedList选取

* 查询、修改操作频繁则使用`arrayList`
* 添加、删除操作频繁则使用`LinkedList`



---

##### (23) 不要让方法有太多的形参

当方法需要多个参数时，建议将其封装到一个实体类中，以实体类为参数。



---

##### (24) 字符串变量和字符串常量使用equals比较时，将常量写在前

```Java
String str = "123";
if (str.equals("123"))
{
    ....
}
```

建议替换为如下：可以避免空指针异常

```java
String str = "123";
if ("123".equals(str))
{
    .....
}
```



---

##### (25) toString()方法

* 不要对数组使用toString()，打印出的是地址，如果数组为空还会引起空指针异常
* 集合可以使用toString()打印值，因为其父类重写了该方法
* 基本数据类型转字符串时，`toString()`的效率要高于`valueOf()`



---

##### (26) 公用的集合类中不使用的数据一定要及时remove掉

* 如果一个集合类是公用的，那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。



---

##### (27) 基本数据类型转字符串（三种方式）

* `toString()`效率最高
* `String.valueOf()`效率其次，底层调用`toString()`
* `+`号连接空字符效率最低，底层调用了`StringBuilder`实现



---

##### (28) 最有效率的遍历Map方式

```java
// 使用entrySet()获取所有的键值对，存入set
Set<Map.Entry<String, String>> entrySet = hm.entrySet();
// 使用Stream流遍历set
entrySet.stream().map(
    ...
)
```



---

##### (29) 对资源的close()建议分开

* 使用多个try catch进行操作
* 因为如果前者抛出异常，则会进入catch块中，导致后面的资源无法释放



---

##### (30) 对于`ThreadLocal`，在使用前和使用后，都要进行remove

* 因为利用了线程池技术，线程结束时不销毁。所以可能上条线程设置的数据依然存在
* 即在get数据时，可能得到的是上一条线程set的值



---

##### (31) 重写方法时添加`@Override`注解

* 可以知道该方法是重写父类
* 可以判断是否重写成功
* 父类修改该方法时，会报编译错误



---

##### (32) 对象的比较

* 重写equals方法，否则比较的是地址值
* 推荐使用Objects工具类进行对象的比较，避免空指针异常的风险



---

##### (33) 程序编写时，尽量避免出现运行时异常，如下：

* ArithmeticException可以通过判断除数是否为空来规避
* NullPointerException可以通过判断对象是否为空来规避
* IndexOutOfBoundsException可以通过判断数组/字符串长度来规避
* ClassCastException可以通过instanceof关键字来规避
* ConcurrentModificationException可以使用迭代器来规避



---

##### (34) 多线程时，使用ThreadLocalRandom获取随机数



---

##### (35) 静态类、单例类、工厂类将它们的构造函数置为private

这是因为静态类、单例类、工厂类这种类本来我们就不需要外部将它们new出来，将构造函数置为private之后，保证了这些类不会产生实例对象。





---

### 字符串处理优化

**字符串分隔**

* 常用`split(";")`方法分隔
* 使用工具类`StringTokenizer`效率更高



---

**字符串拼接**

* 使用`StringBuilder`处理效率最高
* 使用 `+` 号效率最低

* 也可以使用`join()`方法拼接



---

##### 基本数据类型转字符串（三种方式）

* `toString()`效率最高
* `String.valueOf()`效率其次，底层调用`toString()`
* `+`号连接空字符效率最低，底层调用了`StringBuilder`实现



---

##### 数组转字符串

* 不能直接使用`toString()`方法，需要使用arrays工具类调用
* 字符数组可以使用`valueOf()`方法转换，底层调用string构造函数
* 可以使用字符串拼接



---

##### 字符串数组转字符串串

* 只能使用字符串拼接方法

