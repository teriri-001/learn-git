# springcloud

## springcloud概述

1. 什么是springcloud
    * 应用层面介绍：
        1. 是一个服务治理平台，提供了一些服务框架：服务注册与发现、配置中心、消息中心、负载均衡、数据监控等
    * 概念定义
        1. SC是一个微服务框架。提供全套的分布式系统解决方案
        2. SC是对微服务基础框架`netfilx`的多个开源组件进行了封装，同时实现了和`云端平台`以及和`springboot开发框架`的集成。
        3. SC为微服务架构开发涉及的：`配置管理，服务治理，熔断机制，智能路由、微代理、控制总线、一次性token、全局一致性锁、leader选举、分布式session、集群状态管理`等提供了简单的开发方式。
        4. SC提供了快速构建分布式系统的工具，可以快速启动服务或构建应用、同时能够快速和云平台资源进行对接。
2. springcloud的位置
    * spring cloud是spring的一个顶级项目，与spring boot位于同一位置
3. spring cloud的子项目 
4. spring cloud版本定义说明
    1. 单词首字母越大表明版本号越大
    2. 使用单词命名的目的在于：更好的管理每个子项目的清单，避免自己版本号与子项目版本号混淆。
    3. 版本发布计划
        * build-xx：开发版
        * GA      ：稳定版，基本可使用
        * PRE     ：里程碑版，修复GA版bug修复。
        * RC      ：候选发布版
        * SR      ：正式发布版
5. 常见版本号说明
    * 软件版本号：2.0.3.RELEASE
        1. 2 --- 主版本号
        2. 0 --- 次版本号
        3. 3 --- 修改版本号
        4. release --- 版本处于的开发阶段（希腊版本号）
6. 常用网站：
    * [中文API文档](https://springcloud.cc/spring-cloud-dalston.html)
    * [springcloud中文网](https://springcloud.cc)
    * [springcloud中国社区](springcloud.cn)



---

## 环境搭建

### 服务提供者

* **创建项目**

  ```xml
  <!-- 新建一个maven项目，去除src文件，只保留pom.xml，为总配置-->
  ```

* **pom.xml配置**

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <groupId>com.enn</groupId>
      <artifactId>ues</artifactId>
      <!--项目打包方式-->
      <packaging>pom</packaging>
      <version>1.0-SNAPSHOT</version>
      <!--模块管理，新建module时自动添加-->
      <modules>
          <module>ues-api</module>
          <module>ues-cim</module>
          <module>ues-common</module>
          <module>ues-data-service</module>
          <module>ues-message-cached</module>
          <module>ues-daily</module>
          <module>ues-data-file-service</module>
          <module>ues-pushdata</module>
      </modules>
      <!--引入父项目-->
      <parent>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-parent</artifactId>
          <version>2.2.3.RELEASE</version>
          <relativePath/>
      </parent>
  
      <properties>
          
          <!--依赖的版本管理-->
          <java.version>1.8</java.version>
          	.......
          
      </properties>
  
      <dependencyManagement>
          
          <dependencies>
              <!--添加需要的依赖-->
          </dependencies>
          <!--springcloud依赖、springboot、数据源配置、测试及日志-->
          <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-dependencies</artifactId>
              <!--版本号一般不写死-->
               <version>${spring-cloud.version}</version>
               <type>pom</type>
               <scope>import</scope>
          </dependency>
          	........
          
      </dependencyManagement>
  
  </project>
  ```

* **在主项目上新增一个module**

  * 每一个为独立的springboot项目，添加相应的配置、数据库等
  * 需要配置spring项目的名称：`spring.application.name:ues-api`

* **服务提供接口**

  ```Java
  // 新建一个controller接口提供服务
  // 提供restful服务，springcloud服务之间通信是通过http实现的，有restTemplate和feign两种方式
  @RestController
  public class provider{
    
      // 自动注入service层实现
      @autowired
      xxxService xxxservice;
      
      //controller接口，提供具体服务
      @PostMapping("/hello")
      public int adduser(user user){
          int addResult = xxxservice.addUser(user);
          return addResult;
      }
  }
  ```
  



### 服务消费者

* 新建一个模块(module)，添加依赖、配置等信息



* **服务消费接口（RestTemplate方式）**

  * [resttemplate详解](https://www.cnblogs.com/chancy/p/8795334.html)
  
  ```Java
// 消费者处于Controller层
  // 使用restemplate（restFul服务模板）调用服务
  @Autowired
  private RestTemplate restemplate;
  
  // CIM服务的地址
  public static final String url = "http://meta-service.test.fnwintranet.com/cim/meta/custom/query";
  
  @RequestMapping("/cim/meta/custom/query")
  public void findCimTree(String stationId,String path,String types){
      // 存放需要传递的参数
      MultiValueMap<String,String> map = new LinkedMultiValueMap<>();
          map.set("stationId",stationId);
          map.set("path",path);
          map.set("types",types);
      // 拼凑url
          UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(cimUrl);
          URI uri = builder.queryParams(map).build().encode().toUri();
      // 使用restTemplast调取服务，服务是get方式
          String cimBody = restTemplate.getForObject(uri, String.class);
  }
  ```
  



---

## Eureka服务注册与发现

[eureka](https://zhuanlan.zhihu.com/p/95696180?from_voters_page=true)是一个服务发现框架，类似于现实中的“中介”

**三大角色**

* **服务提供者**：就是提供一些自己能够执行的一些服务给外界，如房东出租房子
* **服务消费者**： 就是需要使用一些服务的“用户”。如租客
* **服务中介**：提供服务的注册与发现



**eureka包含两个组件**

* **eureka server**：提供服务注册功能，从而在其服务注册表中存放了所有可用服务节点信息
* **eureka client**：用于简化eureka service的交互，`Eureka`客户会每隔30秒(默认情况下)发送一次心跳来续约



**基础概念**

* **服务注册**：当 `Eureka` 客户端向 `Eureka Server` 注册时，它提供自身的**元数据**，比如IP地址、端口，运行状况指示符URL，主页等

* **服务续约**：**`Eureka`** **客户会每隔30秒(默认情况下)发送一次心跳来续约**。 通过续约来告知 `Eureka Server` 该 `Eureka` 客户仍然存在，没有出现问题。

* **获取注册列表信息**：`Eureka` 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。

* **服务下线**：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。

  ```java
  // 需要手动下线
  DiscoveryManager.getInstance().shutdownComponent();
  ```

* **服务剔除**：默认的情况下，**当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除**



---

### eureka server

**添加依赖**

```bash
# 添加服务注册中心的依赖
	- spring-cloud-starter-eureka-server
```

**添加配置文件**

```yaml
server:
 port: xxxx

# 配置eureka
eureka:
 instance:
   hostname: xxx #eureka服务端的实例名称
 # 配置客户端连接信息
 client: 
   register-wit-eureka: false #是否向eureka注册中心注册自己，由于配置server所以不需要
   fetch-register: flase # 表示自己为注册中心
   service-url: # 配置访问地址，一般不写死 ，集群配置时在这关联其他注册中心
     defaultZone: http://主机名:端口号/eureka/,http://主机名:端口号/eureka/。。。。
   
```

**启动eureka服务功能**

* 在springboot启动类添加注解：`@EnableEurekaServer`



**自我保护机制**

某一时刻，一个微服务不可用，eureka不会立刻清理，依旧会对该微服务的信息保存

* 默认情况下：

  ​	当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除

  

* 自我保护模式中：

  ​	EurekaServer会保护服务注册表中的信息，不再注销任务服务实例。当微服务恢复时，会推出自我保护模式



* 禁用自我保护模式（不关）：

  ```properties
  # 在配置文件中添加配置
  eureka.server.enable-self-preservation = false
  ```

  

---

### 服务注册

**添加依赖**

```bash
# 添加服务提供者的依赖
	- spring-cloud-starter-eureka
	
# 完善服务监控信息
	- spring-boot-starter-actutor
```



**配置文件**

```yaml
# 端口号
server:
  prot: 8081

# 应用名称
spring:
  application:
    name: spring-cloud-provider
    
# eureka配置
eureka:
  client:
    service-url:
      defalutZone: http://主机名:端口号/eureka/ #服务注册地址，即eureka server 配置的地址

# 添加服务监控信息（键值对）,可以显示在服务注册中心
info:
  app.name: xxx
```

**开启功能**

* 在启动类添加注解：`@EnableEurekaClient`
* 将自动将服务注册到注册中心

**获取服务信息**

* 需要在启动类开启功能：`@EnableDisconver` ，允许被发现

```Java
// 通过discoverClient获取
@Autowired
private DisConverClient client;

// 获取信息
@GetMapping("/disconver")
public Object discover(){
    
    // 获取微服务列表清单
    List<String> services = client.getServices();
    
    // 获取一个具体微服务信息,通过服务id获取（即配置的applicationName)
    List<ServiceInstances> instances = services.getInstance(applicationName);
    
    // 获取微服务信息
    for (ServiceInstances instance: instances){
        instance.getHost(); //获取主机ID
        .....
    }
}
```



---

## feign

使用接口方式调用服务

**导入依赖**

```
spring-cloud-starter-eureka-Feign
```

**编写接口**

```java
@Feign(value="xxx") //value为服务提供者配置的application.name
// 添加提供的服务接口
public interface providrservice{
    //获取能源消耗曲线
    @ApiOperation(value = "获取能源消耗曲线接口", notes = "查询")
    @GetMapping("/energyConsumption/findList/{stationId}")
    public List<TremdLineVO> findList(@PathVariable("stationId") String stationId, @RequestHeader("simulate") String simulate) throws ParseException ;
}
```

* 需要使用服务时，自动注入该接口，即可调用服务
* 需要在启动类添加注解：`@EnableFeignClients(basePackages="接口路径")`