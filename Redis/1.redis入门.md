# redis入门

## Nosql概述

1. 单机mysql（阶段一）
   1. 数据量大难以存放
   2. 数据的索引(超过300万条数据就一定要建立索引)太大也难以存放
   3. 访问量大，服务器承受不了
2. Memcached(缓存) + MySQL + 垂直拆分(读写分离)（阶段二）
   1. 网站大多数都在读操作，可以添加缓存减轻数据压力，缓存即第一次读，缓存为空，则读数据库，并写入缓存，下次读缓存时可以直接从缓存读取。
   2. 发展过程：优化数据结构和索引—–>文件缓存—–>Memcached缓存技术
   3. 读写分离，即存在多个数据库，一些数据库专门用于写，一些数据库专门用于读
3. 分库分表 + 水平拆分 + mysql集群
   1. 集群即把几个数据库放在一起作为一个集群，同时该集群存在多个
4. 最近



## redis入门

1. 用途
   1. 内存存储（断电即失）、持久化
   2. 效率高、可以用于高速缓存
   3. 发布订阅系统
   4. 地图信息分析
   5. 计时器、计数器（浏览量等）
2. 特性
   1. 多样的数据类型
   2. 持久化
   3. 支持集群
   4. 支持事务操作
3. redis推荐在Linux服务器搭建
4. redis是单线程的
   1. 单线程原因：Redis是基于内存操作，所以CPU不是性能瓶颈，Redis的瓶颈是机器的内存和网络带宽。所以可以使用单线程来实现
   2. 单线程还快的原因：
      1. 误区：多线程一定比单线程效率高
      2. 原因：数据存放在内存中，没有多线程的CPU上下文切换的耗时操作

## 五大数据类型

1. **redis-key**：redis的命令，用于管理redis的键

   |          命令          |                             功能                             |
   | :--------------------: | :----------------------------------------------------------: |
   |   ==set== key value    |                        创建一个键值对                        |
   |      ==get== key       |                       返回key对应的值                        |
   |      ==del== key       |                        删除指定的缓存                        |
   |     ==exists== key     |                       检查key是否存在                        |
   |      ==keys== \*       |                      查看所有缓存的key                       |
   | ==expire== key seconds |              为给定key设定过期时间，以秒为单位               |
   |    ==move== key db     | 将当前数据库的key移动到指定的数据库中，redis默认存在0~15号的16个数据库 |
   |      ==ttl== key       |               以秒为单位返回key的剩余过期时间                |
   | ==rename== key newkey  |                        修改key的名称                         |
   |      ==type== key      |                   查看key对应值的数据类型                    |
   |          更多          |          [官网](http://www.redis.cn/commands.html)           |

2. **string**

   1. 设置值：`set key value`
   2. 获取值：`get key`
   3. 尾部追加字符：`append key “拼接字符串”` ，如果该key不存在，则创建该key
   4. 获取字符串的长度：`strlen key`
   5. 值的自增与自减：`incr\decr key` ，自增或者自减1
   6. 设置自增步长：`incrBy\decrBy key 10`，自增或自减10
   7. 截取部分字符串显示：`getrange key start end`，包含start、end
   8. 字符替换：`setrange key index value`，将下标为index（包含index）之后对应长度的字符替换为value
   9. `setex key 30 “hello”`：设置key的值为“hello”，30秒之后过期
   10. `setnx key “redis”`：如果key不存在则创建，并赋值为redis；若存在则创建失败
   11. 批量创建：`mset k1 v1 k2 v2...`
   12. 批量获取值：`mget k1 k2....`
   13. 更新值：`getset key value`，获取key的值，如果不存在则返回空并设置value，如果存在则返回上一个value，并更新value

3. **List(列表)**

   1. 可以将其用作栈、队列、阻塞队列等

   2. 常用命令：常在命令前加==L==

      1. `Lpush list value`：将一个或多个值从头部插入list
      2. `Rpush list value`：将一个或多个值从尾部插入list
      3. `Lpop list`：从头部移除一个值
      4. `Rpop list`：从list尾部移除一个值
      5. `Lrange list index`：通过下表获取list中的某一个值
      6. `Llen list`：返回list长度
      7. `Lrem list number value `：移除value值匹配的指定个数
      8. `Lset list index value`：更新指定下标的值
      9. `Linsert list before\after value1 value2`：向value1的前或后插入值
      10. `Ltrim list start end`：截取list
      11. `Lrange list start end`：获取指定范围的值，`lrange list 0 -1`可以获取所有

   3. **set(集合)**

      1. set中的值不可以重复

      2. 常用命令

         |         命令          |              说明              |
         | :-------------------: | :----------------------------: |
         |  ==sadd== set value   |         向集合中添加值         |
         |     ==scard== set     |      获取集合中的元素个数      |
         |   ==smembers== set    |      获取集合中的所有元素      |
         | ==smove== s1 s2 value |  将集合s1中的元素移动到集合s2  |
         |    ==sdiff== s1 s2    | 返回集合s1中与集合s2不同的元素 |
         |   ==sinter== s1 s2    |      返回给定给集合的交集      |
         |   ==sunion== s1 s2    |       返回给定集合的并集       |

   4. **hash(哈希)**

      1. Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。

      2. 常用命令

         |               命令               |                 说明                  |
         | :------------------------------: | :-----------------------------------: |
         | ==Hset\Hmset== hash k1 v1 k2 v2… |       设置一个或多个hash字段值        |
         |    ==Hget\Hmget== hash k1 k2…    |         获取一个或多个字段值          |
         |         ==hgetall== hash         |          获取hash中的所有值           |
         |         ==hkeys==  hash          |             获 取所有key              |
         |          ==hvals== hash          |              获取所有值               |
         |               其他               | 与string命令几乎一致，需要在前加==h== |

   5. **zset(有序集合)**

      1. Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。

      2. 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

      3. 常用命令

         |                     命令                      |                          说明                          |
         | :-------------------------------------------: | :----------------------------------------------------: |
         |           ==ZADD== set score value            | 向有序集合添加一个或多个成员，或者更新已存在成员的分数 |
         |            ==zcount== key min max             |          计算在有序集合中指定区间分数的成员数          |
         | ==zrevrangebyscore== set max min [withscores] |   返回有序集中指定分数区间内的成员，分数从高到低排序   |
         |                     其他                      |          与set命令基本相似，需要在前添加==z==          |

## 三种特殊数据类型

1. **geospatial(地理位置)**

   1. 主要用于存储地理位置信息，并对存储的信息进行操作

   2. 常用命令

      |                   命令                   |                             说明                             |
      | :--------------------------------------: | :----------------------------------------------------------: |
      |      ==geoadd==  key 纬度 经度 名称      | 添加一个地理位置，经纬度有限制。操作时一般会下载数据通过Java程序一次性导入 |
      |           ==geopos== key 名称            |                     获取指定城市的经纬度                     |
      |    ==geodist== 名称1 名称2 [距离单位]    |          获取两城市之间的绝对位置，可以指定距离单位          |
      |    ==georadius== key 经纬度 半径 单位    |       以给定的经纬度为中心，找出key中给定半径内的元素        |
      | ==georadiusbymember== key 名称 半径 单位 |         以指定元素为中心，找出key中给定半径内的元素          |
      |                   其他                   |      geo底层实现原理是zset，故可以使用zset的命令操作geo      |

2. **hyperloglog(基数统计)**

   1. 基数：数据集合中不重复的元素个数

   2. 优点：计数时占用内存小且固定，错误率低

   3. 使用：当任务可以容错（如页面访问人数统计）时，可以使用该方法，否则可以使用set方法（set元素唯一的特性）或自己的数据类型

   4. 常用命令

      |           命令            |                说明                 |
      | :-----------------------: | :---------------------------------: |
      | ==pfadd== key v1 v2 v3….  |         添加一个或多个元素          |
      |      ==pfcount== key      |       统计key中元素的基数数量       |
      | ==pfmerge== key key1 key2 | 将key1和key2合并，并将结果返回给key |

3. **bitmaps**

   1. 位图：只有二进制01状态的字符串，用其中每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多（两个状态）的情况

   2. 优点：内存占用小

   3. 常用命令

      |             命令              |                            说明                             |
      | :---------------------------: | :---------------------------------------------------------: |
      |  ==setbit== key index value   |         添加位图，即在指定位置index添加状态值value          |
      |     ==getbit== key index      |                  获取位图指定位置的状态值                   |
      | ==bitconunt== key [start end] | 统计位图中状态为1的字符个数，可以指定范围，不指定则统计全部 |

## 事务操作

1. 事务概述
   1. 事务即一组命令的集合并在一起执行
   2. redis的事务不保证原子性，即不会一条命令失败，则整个事务失败
   3. redis的事务没有隔离级别的概念
   4. 事务在入队时不会执行，只有在发起执行命令时入队的命令才会依次执行
2. 事务执行流程
   1. 开启事务：`multi`
   2. 命令入队：添加需要执行的命令
   3. 执行事务：`exec`
   4. 放弃事务：`discard`，即添加入队的命令都不再执行
   5. 命令错误
      1. 编译型异常，即入队的命令有错误，则事务中所有命令都不会执行
      2. 运行时异常，入队的命令没有错，但是逻辑错误(如1/0)，则其他命令不用遵守原子性可以正常执行，而错误命令抛出异常

## redis实现乐观锁

1. [乐观锁和悲观锁](https://zhuanlan.zhihu.com/p/31537871)

   1. 悲观锁：基于悲观的态度防止数据冲突，无论做什么都会加锁，影响效率
   2. 乐观锁：对数据冲突保持乐观，数据操作时不加锁，只有到数据提交的时候才通过一种机制（vision版本比较）来验证数据是否存在冲突

2. redis的watch监视实现乐观锁

   ```bash
   # 设置了余额和消费金额两个数据
   set money 100
   set spend 0
   # watch监视余额这个数据，实时监控该数据值
   watch money
   # 一个进程开启事务操作余额
   multi
   decrby money 10
   incrby spend 10
   # 提交事务时，如果money被其他进程更改导致值发生变化，则会提交失败
   exec
   # 解锁
   unwatch
   # 重新加锁，获取最新的money值,再执行事务操作
   watch money
   ```

   





