# Redis进阶

## Redis.conf详解

redis启动时，通过配置文件来启动

1. 注意事项

   1. 配置文件中单位不区分大小写
   2. 包含，可以将多个`.conf`文件组合成一个

2. 网络配置

   ```bash
   bind 127.0.0.1 #绑定的IP地址
   protected-mode yes #保护模式，一般开启
   port 6379 #端口设置
   tcp xxx #TCP配置，一般不管
   ```

3. 通用配置

   ```bash
   daemonize yes #是否以守护进程的方式开启(后台进程)，默认是no,需要开启
   supervised no #管理守护进程，默认为no，不用修改
   pidfile /var/ren/.../ #如果以后台进程运行，则需要指定一个pid文件
   loglevel notice #日志级别
   logfile “” #日志的文件位置名，为空则为标准输出
   database 16 #数据库数量，默认16个
   always-show-logo yes #是否显示logo，连接时显示的那个
   ```

4. 快照配置：

   1. 做持久化时配置

   2. 持久化：在规定时间类，执行了多少次操作，会持久化到文件(rdb文件、aof文件)

      ```bash
      # xxx秒内，至少有xxx个key进行了修改，就进行持久化操作
      save 900 1
      save 300 10
      save 60 10000
      # 需要自定该配置
      stop-writes-on-bgsave-error yes #持久化如果出错，是否还需要继续工作，一般为是
      rdbCOmpression yes #是否压缩rdb文件，需要消耗CPU资源
      rdbchecksum yes #保存rdb文件时，是否运行错误的检查校验
      dir ./ #rdb文件保存的目录，默认为当前目录
      dbfilename xxx.rdb #rdb文件名配置
      ```

5. 主从复制配置

   ```bash
   replicaof 主机ip 主机端口号 # 从机配置，永久有效
   ```

   

6. 安全配置

   ```bash
   requirepass #登录密码，默认没有，一般使用命令配置
   ```

7. 限制

   ```bash
   maxclients 10000 #客户端最大连接数
   maxmemory <bytes> # redis配置最大的内存容量，默认为bytes
   maxmemory-policy noeviction # 内存到达上限时的处理策略，6种策略
   ```

8. aof配置

   ```bash
   appendonly no #默认不开启aof模式，即默认使用rdb方式持久化
   appendfilename "xxx" #持久化的文件的名称
   appendsync everysec # 同步策略
   no-appendfsync-on-rewrite no #是否开启日志重写时正常追加，no为正常追加，yes为将命令放在缓冲区
   auto-aof-rewrite-min-size 64mb #文件大小超过64mb会创建一个新进程进行重写文件
   ```

## 持久化之RDB

redis是内存数据库，不进行持久化到磁盘中，那么当服务器进程关闭，则数据会消失。所以需要持久化功能

1. **功能**：在指定的时间间隔内，将内存中的数据集合快照（**快照是数据存储的某一时刻的状态记录；备份则是数据存储的某一个时刻的副本。这是两种完全不同的概念**），恢复时是将快照文件直接读到内存中
2. **执行思路**：redis会单独的创建一个子进程来进行持久化，会先将数据写到一个临时RDB文件中，待持久化过程完成，再用这个临时文件替换上次持久化产生的RDB文件。
3. **缺点**：
   1. 最后一次持久化的数据可能丢失，所以需要一定的时间间隔
   2. 创建子进程时，会占用一定的内存空间
4. **优点**：
   1. 适合大规模的数据恢复（因为会创建一个子进程执行）
   2. 适合对数据完整性要求不高（最后一次执行持久化可能会丢失数据）
5. 注意：
   1. 默认持久化都是RDB模式，一般情况下不需要修改这个配置
   2. RDB比AOF更加高效
   3. 一般生产环境下，会将rdb文件备份
6. **RDB文件**
   1. 默认是dump.rdb文件，保存在bin目录下。可以在配置文件中
   2. 使用`save xxx xxx`配置
   3. 生成规则
      1. 数据操作满足`save`的配置时，会自动生成一个RDB文件
      2. `flashall`和`flashdb`清空数据库命令也会生成一个rdb文件
      3. 使用`shotdown`退出redis时，也会产生一个rdb文件
   4. 恢复rdb文件
      1. 只需要将rdb文件放到redis启动目录（ bin目录 ）下即可，redis启动时会自动检查该文件，并恢复数据

## 持久化之AOF

将我们执行的所有命令都记录下来，恢复的时候相当于将命令再执行了一遍

1. **执行流程**：以日志的形式来记录每一个写操作（读不记录），只允许追加AOF文件，不允许改写文件，redis启动时会读取该文件重新构建数据
2. **注意**
   1. 默认不开启AOF，需要手动配置
3. **AOF文件**
   1. AOF默认保存的是`appendonly.aof`文件，保存在bin目录下
   2. 使用`appendsync xxx`配置数据同步策略
   3. 恢复aof文件
      * 当aof文件被人为的修改之后有错误，将无法启动redis
      * aof文件有错误，可以使用`redis-check-aof`自动修复
      * aof文件正常，启动后即可恢复数据到内存
   4. 重写规则
      * redis 随着命令不断的写入数据，aof 文件会越来越大。为了解决这个问题，redis 引入了 aof 文件重写机制
      * 重写即将 redis 中的数据转换为 写命令同步更新到 aof 文件的过程
      * 
   5. 重写压缩体积原因
      * 清除了一些无效命令 
      * 进程内超时的数据不再写入 aof 文件
      * 多条写命令可以合并为批量写命令
4. **[bgrewriteaof机制](https://www.cnblogs.com/lyh233/p/13196231.html)**：在一个子进程中进行aof的重写，从而不阻塞主进程对其余命令的处理，同时解决了aof文件过大问题

## redis发布订阅

1. 概述
   1. 发布订阅是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息
   2. 常用消息队列：当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，而部分数据库如Redis、Mysql以及phxsql也可实现消息队列的功能
   3. 订阅-发布模式：
      1. 发送者
      2. 频道
      3. 接收者
   4. 原理：
      1. redis维护了一个字典，其中的键就是一个个频道，而字典的值是一个链表，链表中保存了所有订阅这个频道的客户端
      2. 所以订阅即将客户端添加到指定的订阅链表中
      3. 发送消息时，redis会使用给定频道作为键，找到对应的订阅链表值，遍历该链表，将消息发送给所有订阅者

## redis主从复制

1. **主从复制**：

   1. 是将一台服务器的数据，复制到其他的服务器。前者称为主节点（master），后者称为从节点（slave）
   2. 数据复制是单向的，只能由主节点到从节点
   3. 主节点以写操作为主，从节点以读数据为主，实现读写分离，减轻服务器读数据压力
   4. 最低集群配置，需要三台服务器，即一主二从
   5. 默认情况下，每一个服务器都是主节点，所以配置时只用配置从库，不用配置主库
   6. 主节点只能有一个

2. **作用**

   1. 数据冗余：实现了数据备份，是持久化之外的一种数据冗余方式
   2. 故障恢复：主节点坏了，从节点可以顶上
   3. 负载均衡：主从复制基础上，配合读写分离，缓解服务器负载
   4. 高可用（集群）基石：是哨兵和集群能够实施的基础

3. **使用事项**

   1. 结构上，单个服务器会发生故障，且处理数据压力大
   2. 容量上，单台redis服务器最大使用内存不能超过20G

4. **环境配置**

   1. 查看当前库的信息![](C:\Users\yangyim\Pictures\snipaste\Snipaste_2020-09-11_11-34-17.jpg)
   2. 为每一个从节点创建一个配置文件，修改对应的配置信息
      1. 端口号
      2. pid名称
      3. log文件名称
      4. RDB持久化生成文件名称
   3. 使用对应的配置文件启动服务器，当前服务器默认都是主节点

5. **配置从机**

   1. 环境配置成功之后，每一台服务器都默认是主节点，所有只需要在从机中配置即可

      ```shell
      # 使用命令配置，真实开发中应该使用配置文件配置
      slaveof 主机地址 主机端口号 #客户端使用命令配置从机，暂时有效
      ```

   2. 使用配置文件配置从机，能够使配置永久有效

6. **[主从复制原理](https://www.cnblogs.com/hepingqingfeng/p/7263782.html)**

   1. 主从同步策略：主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步
   2. 全量同步：复制所有数据
   3. 增量同步：主节点每次写入便进行同步

7. **注意事项**

   1. 主机可以写操作，从机不能写只能读数据
   2. 主机中的所有信息和数据，都会被从机保存
   3. 默认情况下（没有配置哨兵），主机宕机之后，从机不会发生改变。需要自己从新设置主机
   4. 从机断开之后，从机配置如果不是使用配置文件，则从机会自动断开与主节点连接变回主机

8. **手动配置主机**

   ```bash
   slaveof no one #使该服务器变回主机，让其他节点可手动连接到该节点成为从机
   ```

9. **[哨兵模式](https://www.jianshu.com/p/06ab9daf921d)**

   1. 功能：
      1. 监控：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常
      2. 提醒：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知
      3. 自动故障转移：

## [Redis缓存穿透和雪崩](https://baijiahao.baidu.com/s?id=1655304940308056733&wfr=spider&for=pc)

### 缓存穿透

1. **概念**

   当用户查询一个数据，首先查询redis缓存，当redis内存数据库中没有该数据。于是会向持久层数据库查询（如mysql），如果持久层数据库也没有，于是本次查询失败。当很多用户请求该类数据时，缓存形同虚设，这会给持久层数据库造成很大压力，即出现了缓存穿透。

2. **解决方案**

   1. 布隆过滤器
   2. 缓存空值

## 缓存击穿

1. **概念**

   存在一个热点数据，多人访问，当该key在失效瞬间，则该大并发就击穿了缓存，直接请求数据库，造成数据库压力（如微博服务器宕机）

2. **解决方案**

   1. 设置热点数据永远不过期
   2. 加互斥锁，每次只让一个线程读取数据

### 缓存雪崩

1. **概念**

   缓存层出现了错误（如缓存集体失效，redis宕机），不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况

2. **解决方案**

   1. redis高可用
   2. 限流降级
   3. 数据预热





