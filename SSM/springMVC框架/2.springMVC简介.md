# springMVC

​	Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架

---

## 简介

**中心控制器**

* Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。	
* Spring MVC框架像许多其他MVC框架一样, **以请求为驱动，围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet** 

**springMVC执行原理**

​	前端控制器（核心部件）：负责拦截前端所有的请求，以及任务的调度、分发

* 前端控制器将任务交给映射器
* 映射器根据前端请求的相关url地址获取相关配置信息( controller层中的类或方法 ，称之为Handler)，并返回Handler对象给前端控制器
* 前端控制器将Handler交给适配器
* 适配器按照特定的规则去执行Handler，Handler让具体的Controller执行
* cotroller接口返回信息封装到ModelAndView对象中交给前端控制器
* 前端控制器将ModelAndView 调度分发给视图解析器
* 视图解析器解析请求页面的信息，最后数据响应到前端对应页面进行渲染

![](C:\Users\yangyim\Pictures\snipaste\Snipaste_2020-09-04_09-30-33.jpg)



---

## 注解开发

1. pom.xml配置

   ```xml
   // 由于Maven可能存在资源过滤的问题，我们将配置完善
   <build>
      <resources>
          <resource>
              <directory>src/main/java</directory>
              <includes>
                  <include>**/*.properties</include>
                  <include>**/*.xml</include>
              </includes>
              <filtering>false</filtering>
          </resource>
          <resource>
              <directory>src/main/resources</directory>
              <includes>
                  <include>**/*.properties</include>
                  <include>**/*.xml</include>
              </includes>
              <filtering>false</filtering>
          </resource>
      </resources>
   </build>
   //在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！
   ```

2. web.xml配置

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
            version="4.0">
       <!--注册servlet-->
       <servlet>
           <servlet-name>SpringMVC</servlet-name>
           <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
           <!--初始化Spring配置文件的位置-->
           <init-param>
               <param-name>contextConfigLocation</param-name>
               <param-value>classpath:springmvc-servlet.xml</param-value>
           </init-param>
           <!--启动顺序，数字越小，启动越早-->
           <load-on-startup>1</load-on-startup>
       </servlet>
       <!--所有的请求都会被SpringMVC拦截-->
       <servlet-mapping>
           <servlet-name>SpringMVC</servlet-name>
           <url-pattern>/</url-pattern>
       </servlet-mapping>
   </web-app>
   <!--这是使用注解开发时固定的配置，不需要改动-->
   ```

3. 添加springMVC配置

   ​	在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:mvc="http://www.springframework.org/schema/mvc"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context
          https://www.springframework.org/schema/context/spring-context.xsd
          http://www.springframework.org/schema/mvc
          https://www.springframework.org/schema/mvc/spring-mvc.xsd">
   
       <!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 -->
       <context:component-scan base-package="com.xuw.controller"/>
       <!-- 让Spring MVC不处理静态资源 -->
       <mvc:default-servlet-handler />
       <!--
       支持mvc注解驱动
           在spring中一般采用@RequestMapping注解来完成映射关系
           要想使@RequestMapping注解生效
           必须向上下文中注册DefaultAnnotationHandlerMapping
           和一个AnnotationMethodHandlerAdapter实例
           这两个实例分别在类级别和方法级别处理。
           而annotation-driven配置帮助我们自动完成上述两个实例的注入。
        -->
       <mvc:annotation-driven />
   
       <!-- 视图解析器
   		在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问
    	-->
       <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
             id="internalResourceViewResolver">
           <!-- 前缀 -->
           <property name="prefix" value="/WEB-INF/jsp/" />
           <!-- 后缀 -->
           <property name="suffix" value=".jsp" />
       </bean>
   
   </beans>
   <!--这也是固定配置，需要修改的只有需要注入IOC的包-->
   ```

4. 创建Controller

   ```Java
   @Controller //跳转到视图(.jsp)
   @RequestMapping("/HelloController")
   public class HelloController {
       @RequestMapping("/hello")
       //方法中声明Model类型的参数是为了把controller中的数据带到视图中；
       public String sayHello(Model model){
           /**
           *数据封装：向模型中添加属性msg与值，可以在JSP页面中取出并渲染
           *Spring MVC会自动实例化一个Model对象用于向视图中传值
           */
           model.addAttribute("msg","hello,SpringMVCAnnotatiom!");
           //跳转到视图解析器，视图名称hello.jsp：web-inf/jsp/hello.jsp
           return "hello";
       }
   }
   ```

5. 创建视图层

   ​	在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出（使用EL表达式）并展示从Controller带回的信息

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
      <title>SpringMVC</title>
   </head>
   <body>
   ${msg}
   </body>
   </html>
   ```

6. 配置tomcat：开启服务器

7. 总结：

   使用springMVC必须配置的三大件：

   **处理器映射器、处理器适配器、视图解析器**

   通常，我们只需要**手动配置视图解析器**，而**处理器映射器**和**处理器适配器**只需要开启**注解驱动**即可，而省去了大段的xml配置



---

## [Restful风格](https://blog.csdn.net/qq_27026603/article/details/82012277)

**概述**

​	Restful就是一个资源定位及资源操作的风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。

**Rest基本原理**

* 系统上的一切对象都要抽象为资源

* 每个资源对应唯一的资源标识（URI）

  ```
  uri,是统一资源标识符，用来唯一的标识一个资源
  如/users ：表示所有用户信息
  /users/1001 : 表示用户信息中的一位，即某一属性值为1001的用户
  ```

* 对资源的操作不能改变资源标识（URI）本身

  ```
  1. 对资源操作时，资源的标识不能改变，即如对用户查询时URI不能使用QueryUser,新增时不能使用SaveUser。
  2. 正确的做法是，资源标识不变，而使用不同的请求方式表示对资源的不同操作
  如：GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，	PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源
  3. 可以使用@pathvariable获取路径变量
  4. 我们使用浏览器地址栏进行访问默认是Get请求
  ```


---

## 结果跳转方式

**ModelAndView**

* 设置ModelAndView对象 , 根据view的名称和视图解析器跳到指定的页面 

* 原因：页面的真实位置 = 视图解析器前缀 + 视图名称 + 视图解析器后缀

* 示例

  ```xml
  <!-- 视图解析器配置 -->
  <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
       id="internalResourceViewResolver">
     <!-- 前缀 -->
     <property name="prefix" value="/WEB-INF/jsp/" />
     <!-- 后缀 -->
     <property name="suffix" value=".jsp" />
  </bean>
  ```

* 后续springboot中的thremlef模板也是同一原理，前缀template ,后缀 html



**ServletAPI**

* 也可以使用servlet方式实现重定向、转发等功能，springMVC中的servletAPI也是servlet实现的

  ```java
  @Controller
  public class ResultGo {
  	//通过HttpServletResponse进行输出 ,req请求，rsp响应
     @RequestMapping("/result/t1")
     public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
         rsp.getWriter().println("Hello,Spring BY servlet API");
    }
  	//通过HttpServletResponse实现重定向
     @RequestMapping("/result/t2")
     public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
         rsp.sendRedirect("/index.jsp");
    }
  	//通过HttpServletResponse实现转发
     @RequestMapping("/result/t3")
     public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception {
         //转发
         req.setAttribute("msg","/result/t3");
         req.getRequestDispatcher("/WEB-INF/jsp/test.jsp").forward(req,rsp);
    }
  
  }
  ```



**SpringMVC方式（推荐使用）**

* 不使用视图解析器方式，即将视图解析器配置文件注释掉

  ```Java
  @Controller
  public class ResultSpringMVC {
     @RequestMapping("/rsm/t1")
     public String test1(){
         //转发方式一：加"/"
         return "/index.jsp";
    }
  
     @RequestMapping("/rsm/t2")
     public String test2(){
         //转发方式二：显示使用forward请求转发
         return "forward:/index.jsp";
    }
  
     @RequestMapping("/rsm/t3")
     public String test3(){
         //redirect:请求重定向
         return "redirect:/index.jsp";
    }
  }
  ```

* 使用视图解析器，需要添加视图解析器配置

  ```Java
  @Controller
  public class ResultSpringMVC2 {
     @RequestMapping("/rsm2/t1")
     public String test1(){
         //转发，即请求其他地址
         return "test2";
    }
  
     @RequestMapping("/rsm2/t2")
     public String test2(){
         //重定向
         return "redirect:/index.jsp";
         //return "redirect:hello.do"; //hello.do为另一个请求/
    }
  
  }
  ```

  

---

## 数据处理

**参数绑定**

​	**springmvc使用controller方法形参来接收请求的参数**，前端会传递数据到后台来进行处理，springmvc则通过参数绑定组件将请求参数的内容进行数据转换，然后将转换后的值覆给controller方法的形参，这就是参数绑定的过程

* **springmvc默认支持的参数类型**

  可以在Controller方法的形参中直接使用以下类型：

  1. **HttpServletRequest**：

  2. **HttpServletResponse**

  3. **HttpSession**：

  4. **Model/ModelMap**：

     

* **绑定简单类型的参数**：规则如下

  * 请求参数名与controller类中方法的形参名一致，则可以直接绑定

  * 请求参数名与controller类中方法的形参名不一致，则需要使用`@RequestParam`注解

    

* **绑定POJO**

  ​	使用springmvc绑定pojo的参数时，要求jsp中input框的name值要和Controller方法形参的pojo对象中的属性名称一致

  

* **参数绑定时日期类型转换问题**

  ​	springmvc会帮我们将前端的一些简单的类型自动进行类型转换，但是当遇到Date类型的时候，就转换不了。需要手动转换。

  ```java
  //示例
  public Date convert(String date){
      SimpleDateFormat sdf = new SimpleDateFormat("需要的日期格式");
      // 会将字符串转换为相应格式的Date类型
      return sdf.parse(date);
  }
  ```



* **集合参数的绑定**

  * 可以使用数组或list来接收，但是**pojo类型的集合参数绑定时，接收它的数组或者List，都不能直接定义在Controller方法形参上，需要把它定义到一个包装pojo中，如何把这个包装pojo放到形参**

  * 也可以直接使用`@Requestparam`注解直接在参数上指定

    

**数据显示到前端**

* 通过`modelAndView`对象

  ```java
  public class ControllerTest1 implements Controller {
  
     public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
         //返回一个模型视图对象，可以在储存数据的同时，进行设置返回的逻辑视图，进行控制展示层的跳转
         ModelAndView mv = new ModelAndView();
         mv.addObject("msg","ControllerTest1");
         mv.setViewName("test");
         return mv;
    }
  }
  ```

* 通过`modelMap 或 model`对象（常用model）

  ```Java
  @RequestMapping("/ct2/hello")
  public String hello(@RequestParam("username") String name, Model model){
     //封装要显示到视图中的数据
     //相当于req.setAttribute("name",name);
     model.addAttribute("msg",name);
     System.out.println(name);
     return "test";
  }
  ```




---

## 数据校验

**什么是数据校验？**

​		就是用来验证客户输入的数据是否合法，比如客户登录时，用户名不能为空，或者不能超出指定长度等要求，这就叫做数据校验



数据校验分为客户端校验和服务端校验

* 客户端校验：js校验

* 服务端校验：springmvc使用validation校验，struts2使用validation校验。都有自己的一套校验规则



---

## 数据回显与自定义异常

**数据回显**

* **什么是数据回显？**

  ​	在数据提交出现错误的时候, 已填写的信息仍在文本框中, 比如用户登录, 当用户输入错误的密码之后, 用户名仍在文本框, 只是密码框清空

  

* **pojo的数据回显**

  * Springmvc默认支持对pojo类型的数据回显，默认不支持简单类型的数据回显

  * Springmvc会把形参中pojo参数，放到request域中，key为pojo参数的类型首字母小写，value为用户填写的内容

    

* **使用注解显式完成回显**

  * **暴露形参到request域**

      将`@ModelAttribute("XXX")`注解加在想要回显的形参的pojo对象前面

  * **暴露返回值到request域**

    ​	将ModelAttribute注解加到方法上时，这个方法就会在requestmapping之前被调用，并且将返回的对象放入request作用域中。示例

    ```Java
    @ModelAttribute
    public Map<String,String> itemsType(){
       Map<String,String> itemsType = new HashMap<>();
       itemsType.put("1001","手机");
       return itemsType;
    }
    //相当于 request.setAttribute("itemsType",itemsType)
    ```



* **总结**

  ​	一般直接使用默认数据回显即可，如果需要改变key，使用注解回显的第一种方式



**[自定义异常处理器](https://blog.csdn.net/mr_mocha/article/details/90547960)**

​		写这个自定义异常处理器的目的就是为了发生异常的，我们能够提供一个更友好的页面，而不是返回一个404或者500的错误提示页面给用户看

​		要求等发生异常时，我们能够捕捉到，并且做一定的事情



* **自定义异常处理类**

  ```Java
  /**
   * 自定制异常类
   *
   */
  @Getter
  public class CustomException extends RuntimeException {
      private int code;
      private String message;
  
      public CustomException(int code, String message) {
          this.code = code;
          this.message = message;
      }
  	// ResultStatusEnum响应结果枚举类
      public CustomException(ResultStatusEnum resultStatusEnum) {
          this.code = resultStatusEnum.getCode();
          this.message = resultStatusEnum.getMessage();
      }
  }
  ```



* **响应结果枚举类**

  ```Java
  /**
   * 响应结果状态枚举类
   */
  @NoArgsConstructor
  @AllArgsConstructor
  public enum ResultStatusEnum {
      /**
       * 请求成功
       */
      SUCCESS(200, "请求成功！"),
  
      /**
       * 密码错误
       */
      PASSWORD_NOT_MATCHING(400, "密码错误");
  
      @Getter
      @Setter
      private int code;
  
      @Getter
      @Setter
      private String message;
  }
  ```

  

* **全局异常处理**

  ```Java
  /**
   * 全局异常处理
   * 全局捕获异常，编写对应的异常处理器
   */
  @ControllerAdvice 
  /**
  * @ControllerAdvice注解，是一个增强的Controller，作用如下
  * 全局异常处理；
  * 全局数据绑定；
  * 全局数据预处理；
  * 参考文档：https://www.cnblogs.com/lenve/p/10748453.html
  */
  public class GlobalExceptionHandler {
      @ResponseBody
      /**
      * 当我们使用这个@ExceptionHandler注解时，我们需要定义一个异常的处理方法
      * @ExceptionHandler注解中可以添加参数，参数是某个异常类的class，代表这个方法专门处理该类异常
      */
      @ExceptionHandler(CustomException.class)
      public Map<String, Object> handleCustomException(CustomException customException) {
          Map<String, Object> errorResultMap = new HashMap<>(16);
          errorResultMap.put("code", customException.getCode());
          errorResultMap.put("message", customException.getMessage());
          return errorResultMap;
      }
  }
  ```

  