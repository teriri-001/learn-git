# mybatis项目

## xml文件配置

1. 两个绑定

   1. 接口的全限定名(路径)要和映射文件的namespace保持一致
   2. 接口中的方法名，和SQL中的id保持一致

2. 全局配置

   ```yaml
   mybatis:
   // 指定POJO扫描包来让mybatis自动扫描到自定义POJO避免在mapper.xml配置文件中使用全类名指定参数
     type-aliases-package: com.sinon.pojo
     // 指定映射文件位置，配合@mapper使用
     mapper-locations: classpath:mybatis/mapper/*.xml
   ```

3. mybatis两种获取参数的方式

   1. ${}：使用statement，字符串拼接操作SQL，需要单引号包裹
   2. ==#{}==：使用prepare statement通配符，不需要单引号，防止SQL注入
   3. 当参数为单个string或基本数据类型时：#{}可以使用任意名称取值，${}只能以value和\_parameter取值
   4. 当传输多个参数时，需要由数字序号或param+序号指定参数，${}只支持后者。因为默认将属性放入了map集合，根据key获取
   5. 当传输map集合参数时，也可以使用key获取值
   6. ==@param==注解：通过注解命名参数，指定引用参数时使用的名称，解决多个参数时的可读性题
   7. 传输参数为list集合或array数组：mybatis也会将其放入map集合，其中集合以list为键、数组以array为键

4. 主键

   1. ==usegeneratedkeys==：可以使用自动生成的主键
   2. ==keyproperty==：将自动生成的主键赋值给参数中的的指定属性

5. 自定义参数映射

   1. 处理复杂的表关系时，如多表联查，会出现参数映射问题，需要自定义映射

   2. 多对一自定映射（方式一级联）

   ```xml
   <mapper namespace="mapper接口路径">
       // 使用resultmap自定义映射
       <resultmap type="需要映射到的实体类名称" id="指定id,便于引用">
           // id用于设置主键值的映射
           <id column="字段名" property="实体类对应属性名"></id>
           // result用于设置非主键的映射
           <result column="普通字段" property="对应属性"></result>
           ......多条
           // 多表联查时，方式一级联方式
           <result column="外键名" property="使用全类名指定属性ps->(dept.did)"></result>
       </resultmap>
       // 以查询语句为例
       <select id="mapper接口名" resultmap="设置的id">
           sql语句
       </select>
   </mapper>
   ```

   3. 多对一自定义映射：==association==(方式二)

   ```xml
   <mapper namespace="mapper接口路径">
       // 使用resultmap自定义映射
       <resultmap type="需要映射到的实体类名称" id="指定id,便于引用">
           // id用于设置主键值的映射
           <id column="字段名" property="实体类对应属性名"></id>
           // result用于设置非主键的映射
           <result column="普通字段" property="对应属性"></result>
           ......多条
           // 多表联查时，方式二association
           <association property="不能识别的属性(其他表的pojo类类名)"javatype="pojo类类型">
               与上相同，id设置主键，result设置非主键
           </association>
       </resultmap>
       // 以查询语句为例
       <select id="mapper接口名" resultmap="设置的id">
           sql语句
       </select>
   </mapper>
   ```

   4. association多对一分步查询：

      1. 一个联合查询可以分为多步骤的对单表的查询，以查询员工及其所属部门信息为例

         * 涉及了员工信息表、部门信息表
         * 分步查询即先查询出员工信息，再通过返回的部门id查询出部门信息
         * 即存在两个mapper映射文件，通过主表自定义映射实现分步查询

      2. 实现示例

         ```xml
         <mapper namespace="mapper接口路径">
             // 使用resultmap自定义映射
             <resultmap type="需要映射到的实体类名称" id="指定id,便于引用">
                 // id用于设置主键值的映射
                 <id column="字段名" property="实体类对应属性名"></id>
                 // result用于设置非主键的映射
                 <result column="普通字段" property="对应属性"></result>
                 ......多条
                 // association分步查询
                 <association property="第二步查询的表名，也是第一步实体类中的对象属性" select="第一步查询的接口全限定类名称" column="第二步查询需要用到的结果">
                     与上相同，id设置主键，result设置非主键
                 </association>
             </resultmap>
             // 以查询语句为例
             <select id="mapper接口名" resultmap="设置的id">
                 sql语句
             </select>
         </mapper>
         ```

      3. 分步查询的延迟加载

         1. 延迟加载只对分步查询有效，可以提升查询效率

         2. 需要再全局的配置文件中添加setting配置如下

            ```xml
            // 开启延迟加载，默认为false
            <setting name="lazyloadingenabled" value="true"></setting>
            // 设置加载数据是按需求还是全部加载,默认为true
            <setting name="aggressivelazyloading" value="false"></setting>
            ```

   5. 一对多和多对多自定义映射：==collection==

      1. 当一对多关系时，实体类中的其他表类属性则应该为一个集合，所以需要使用collection解决映射问题

      2. 实现示例

         ```xml
         <mapper namespace="mapper接口路径">
             // 使用resultmap自定义映射
             <resultmap type="需要映射到的实体类名称" id="指定id,便于引用">
                 // id用于设置主键值的映射
                 <id column="字段名" property="实体类对应属性名"></id>
                 // result用于设置非主键的映射
                 <result column="普通字段" property="对应属性"></result>
                 ......多条
                 // association分步查询
                <collection property="实体类的外键集合属性" oftype="集合中对象的类型">
                    与上相同，id设置主键，result设置非主键
                 </collection>
             </resultmap>
             // 以查询语句为例
             <select id="mapper接口名" resultmap="设置的id">
                 sql语句
             </select>
         </mapper>
         ```

         

   6.分步查询的延迟加载控制

   1. ==fetchtype==：控制单个的SQL查询的延迟加载

      1. 用法示例

         ```xml
         // lazy表示设置延迟加载，eager表示关闭延迟加载
         <collection property="实体类的外键集合属性" oftype="集合中对象的类型" fetchtype="lazy|eager"></collection>
         ```

         

