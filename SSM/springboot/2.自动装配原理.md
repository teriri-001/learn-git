# springBoot原理

## 起步依赖

**parent父项目**

* springboot项目pom.xml文件自带父项目：

  ```xml
  <parent>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-parent</artifactId>
          <version>2.2.3.RELEASE</version>
          <relativePath/> <!-- lookup parent from repository -->
  </parent>
  
  -------------上面的父项目是如下所示---------------
  
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-dependencies</artifactId>
      <version>2.2.3.RELEASE</version>
      <relativePath>../../spring-boot-dependencies</relativePath>
  </parent>
  
  ------------spring-boot-dependencies内容----------------
  
  <!---
  	1. 管理了各种依赖的版本
  	2. 可以称之为springboot的版本仲裁中心
  -->
  <properties>
      <activemq.version>5.15.11</activemq.version>
      <antlr2.version>2.7.7</antlr2.version>
      <appengine-sdk.version>1.9.77</appengine-sdk.version>
      <artemis.version>2.10.1</artemis.version>
      <aspectj.version>1.9.5</aspectj.version>
      <assertj.version>3.13.2</assertj.version>
      <atomikos.version>4.0.6</atomikos.version>
      <awaitility.version>4.0.2</awaitility.version>
      <bitronix.version>2.1.4</bitronix.version>
      <build-helper-maven-plugin.version>3.0.0</build-helper-maven-plugin.version>
      <byte-buddy.version>1.10.6</byte-buddy.version>
      <caffeine.version>2.8.0</caffeine.version>
      <cassandra-driver.version>3.7.2</cassandra-driver.version>
      <classmate.version>1.5.1</classmate.version>
      <commons-codec.version>1.13</commons-codec.version>
      <commons-dbcp2.version>2.7.0</commons-dbcp2.version>
      <commons-lang3.version>3.9</commons-lang3.version>
      <commons-pool.version>1.6</commons-pool.version>
      ......
  </properties>
  ```

* **起步依赖**
  * 即`spring-boot-starter`，也称之为springboot的场景启动器
  * 启动器本质：各种功能场景能够正常运行需要的依赖
  * springboot会将各个功能场景抽取出来，变成一个个启动器，使用该功能时，只需要找到该启动器就可以了



---

## 自动装配原理

**springboot主程序**

```Java
@SpringBootApplication //标注一个主程序类，说明这是一个springboot应用
public class SwaggerDemoApplication {

    public static void main(String[] args) {
        
        SpringApplication.run(SwaggerDemoApplication.class, args);
    }

}
```

核心注解：`@springBootApplication`

其源码如下：

```Java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {

	/**
	 * Exclude specific auto-configuration classes such that they will never be applied.
	 * @return the classes to exclude
	 */
	@AliasFor(annotation = EnableAutoConfiguration.class)
	Class<?>[] exclude() default {};

	... ... ...

}
```

**要点解读两个注解：`@SpringBootConfiguration`、`@EnableAutoConfiguration`**

**@SpringBootConfiguration**：springboot的配置类

* 等同于@Configuration，既标注该类是Springboot的一个配置类（ Javaconfig ），也是容器中的一个组件

* 源码如下

  ```Java
  @Target({ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Configuration
  public @interface SpringBootConfiguration {
      @AliasFor(
          annotation = Configuration.class
      )
      boolean proxyBeanMethods() default true;
  }
  ```

**@EnableAutoConfiguration**：开启自动配置的功能

* 简单点说就是它会根据定义在classpath下的类，自动的给你生成一些Bean，并加载到Spring的Context中

* **自动配置原理,主要解读两个注解：`@AutoConfigurationPackage`和`@Import({AutoConfigurationImportSelector.class})`**

  ```Java
  // @EnableAutoConfiguration源码
  @Target({ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Inherited
  @AutoConfigurationPackage
  @Import({AutoConfigurationImportSelector.class})
  public @interface EnableAutoConfiguration {
      String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";
  
      Class<?>[] exclude() default {};
  
      String[] excludeName() default {};
  }
  ```

  * **@AutoConfigurationPackage**：自动配置包

    ```Java
    // @AutoConfigurationPackage源码
    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Inherited
    @Import({Registrar.class})
    public @interface AutoConfigurationPackage {
        String[] basePackages() default {};
    
        Class<?>[] basePackageClasses() default {};
    }
    ```

    **解读@AutoConfigurationPackage**

    * 重点`@Import({Registrar.class})`：spring的底层注解，给容器中导入组件

    * `Registrar.class`：指定可以导入的组件

    * 总结：**`@AutoConfigurationPackage`注解主要工作是，将主配置类（@springbootApplication标注的启动类）所在的包下的所有组件都扫描到IOC容器中**

      ```Java
      static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
              Registrar() {
              }
      /**
      * 将主配置类（@springbootApplication标注的启动类）所在的包下的所有组件都扫描到IOC容器中
      * 这也体现了“约定大于配置”的思想
      */
              public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
                  AutoConfigurationPackages.register(registry, (String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0]));
              }
      
              public Set<Object> determineImports(AnnotationMetadata metadata) {
                  return Collections.singleton(new AutoConfigurationPackages.PackageImports(metadata));
              }
          }
      ```

  * **@Import({AutoConfigurationImportSelector.class})**：导入 “自动配置导入选择器”

    * 将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中
    * 导入的是非常多的自动配置类，以`xxxAutoConfiguration`命名
    * 自动配置类的功能：就是给容器中导入这个场景需要的所有组件，并配置好这些组件
    * 好处：免去了手动编写配置注入功能组件等工作
    * 自动配置类指定：`springFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)`
    * 即springboot在启动时，从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效了，会帮组我们进行自动配置工作
    * 以前spring项目中需要做的事情都需要做，只是springboot帮忙做了而已，这些工作都集中在了spring-boot-autoconfigure.jar下

**总结**

​	springboot项目启动时，通过@SpringBootConfiguration和@EnableAutoConfiguration两个注解完成项目准备工作，其中



