# 常用注解

## springMVC工作原理

1. 前端控制器（核心部件）：负责拦截前端所有的请求，以及任务的调度、分发

   1. 前端控制器将任务交给映射器
   2. 映射器根据前端请求的相关url地址获取相关配置信息( controller层中的类或方法 ，称之为Handler)，并返回Handler对象给前端控制器
   3. 前端控制器将Handler交给适配器
   4. 适配器按照特定的规则去执行Handler，Handler让具体的Controller执行
   5. cotroller接口返回信息封装到ModelAndView对象中交给前端控制器
   6. 前端控制器将ModelAndView 调度分发给视图解析器
   7. 视图解析器解析请求页面的信息，最后数据响应到前端对应页面进行渲染

   ![](C:\Users\yangyim\Pictures\snipaste\Snipaste_2020-09-04_09-30-33.jpg)

## springBoot注解

1. **@RestController**：@Controller和@ResponseBody的合集，用于标注一个类为控制层组件，并表示该类中的接口方法是以JSON格式输出

2. **@RequestMapping**：提供路由信息，负责将进入的 HTTP 请求路由到控制器对应的处理方法上

   1. request对象：是当客户端向服务器端发送请求时，服务器为本次请求创建request对象，Request对象中封装了客户端发送过来的所有的请求数据。
   2. params：指定request中必须包含某些参数值时，才让该方法处理；
   3. headers：指定request中必须包含某些指定的header值，才能让该方法处理请求；
   4. value：指定请求地址
   5. method：请求方式，GET、POST、PUT、DELETE等

3. **@RequestParam**：用在方法的参数前面，将请求参数绑定到控制器的方法参数上，是Spring MVC中接收普通参数的注解

   1. value：请求参数名
   2. required：请求参数是否必须存在
   3. defaultValue：参数默认值
   4. 该注解非必要，当请求参数名和方法形参名一致时，可以正常传值，该注解目的便于方法形参可以随意取名。
   5. 当传递的参数是集合等复杂类型时，需要添加该类注解，否则报错

4. **@PathVariable**：路径变量注解，通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中

   ```Java
   @requestMapping(value = "/user/{id}")
   public user queryUserById(@pathVariable("id") string id){
   	//方法体
   }
   ```

5. **@Component**：表示一个方法为组件( 组件是对数据和方法的简单封装 )，当组件不好归类时，可以使用这个注解进行标注。一般公共的方法会用上这个注解。

6. **@AutoWired**：自动导入依赖的bean，即把配置好的Bean拿来用，完成属性、方法的组装。使用byType的方式注入，即通过Bean的class类型进行匹配

7. **@Service**：注册为一个bean，并且声明为service层的组件

8. **@Repository**：这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。

9. **@Mapper**：为了把mapper这个DAO交給Spring管理，

10. **@MapperScan**：当有多个mapper接口时，可以不用在每一个接口文件添加@mapper注解，而使用@MapperScan指定要扫描的Mapper类的包的路径

11. **@SpringBootApplication**：是Sprnig Boot项目的核心注解，目的是开启自动配置，一般添加在启动类上

12. **@RequestBody**：

    ==前后端参数传递基础知识==

    1. 主要用来接收前端传递给后端的json字符串中的请求体中数据
    2. GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交
    3. 一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。
    4. RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value键值对里面的参数
    5. 如果参数时放在请求体中，传入后台的话，那么后台要用@RequestBody才能接收到；如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收，或则形参前什么也不写也能接收，但是要求请求中的实参要和接口方法中的形参同名才能正确匹配
    6. **@requestBody与前端的JSON数据匹配规则**：前端的HTTP输入流 ( *JSON字符串，含请求体* )装配到@requestBody标注的目标类时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性。

## JPA注解

1. **@Entity**：表名标注的类为一个实体类，让JPA知道哪些类将被持久化/可持久化
2. **@Table**：
   1. 当实体类与其映射的数据库表名不同名时需要使用 @Table注解说明
   2. 可以替代@entity
   3. 如果缺省@Table注解，则class字段名即表中的字段名
3. **@column**：声明该属性与数据库字段的映射关系，不同名 的时候使用
4. **@Id**：声明此属性为主键
5. **@GeneratedValue**：指定主键的生成策略





