# AOP

## 代理模式

​	代理模式是springAOP的底层实现，是23种设计模式之一。



​	代理模式又叫**委托模式**，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。代理模式通俗来讲就是我们生活中常见的中介。

---

### 静态代理

**代理模式角色分析**

* 抽象角色：一般使用接口或者抽象类来实现，**对应租房这件事**。
* 真实角色：也叫被代理角色，是业务逻辑的具体执行者。**对应房东出租房子**
* 代理角色： 代理真实角色 ， 代理真实角色后 , 一般会做一些附属的操作 。**对应中介这一角色**
* 客户：直接接触代理角色。对应**需要租房的人**

**代理模式的优缺点**

优点：

* 真实角色是实现具体的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，代码清晰
* 真实角色随时会发生变化，但是只要实现了接口，接口不变，代理类就可以不做任何修改继续使用，符合“**开闭原则**”。

缺点：

* 多了代理类 , 工作量变大了 . 开发效率降低，**因此产生了动态代理，因为动态代理是通过反射实现**

​		

**代理模式分类**

1. 静态代理
2. 动态代理

---

### 动态代理

**动态代理简介**

* 动态代理的角色和静态代理的一样
* 动态代理的代理类是**通过反射机制动态生成**的 . 静态代理的代理类是我们提前写好的
* 动态代理分为两类 :
  * 一类是基于接口动态代理----JDK动态代理
  * 一类是基于类的动态代理--cglib
  * 现在用的比较多的是 javasist 来生成动态代理



**JDK动态代理实现**

1. 抽象主题角色（租房接口）

   ```Java
   // 租房接口
   public interface Rent {
      public void rent();
   }
   ```

2. 真实角色（房东）

   ```Java
   //房东要出租房子，实现接口
   public class Host implements Rent{
      public void rent() {
          System.out.println("房屋出租");
     }
   }
   ```

3. 通用的动态创建代理对象的类

   ```Java
   public class ProxyInvocationHandler implements InvocationHandler {
      // 被代理的接口（不是接口实例，而是多态实现，使用接口类型指向实现接口该接口的对象
       private Object target;
   	// 接口实现对象的set方法，设置要代理的对象
      public void setTarget(Object target) {
          this.target = target;
     }
   
      /**生成代理类
      *参数分析：
      *ClassLoader loader：类加载器，好像没有限制，只要是loader都行
      *Class<?>[] interfaces：需要代理实现的抽象接口角色
      *InvocationHandler h：得到InvocationHandler接口的子类的实例，可以用this指向自己
      *结果：返回具有由指定类加载器定义并实现指定接口的代理类的实例
      */
      public Object getProxy(){
          return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                  target.getClass().getInterfaces(),this);
     }
   
      // proxy : 代理类
      // method : 代理类的调用处理程序的方法对象.
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          // 可以添加其他附加的方法
          log(method.getName());
          // 利用反射运行真实角色的方法
          Object result = method.invoke(target, args);
          return result;
     }
   
      public void log(String methodName){
          System.out.println("执行了"+methodName+"方法");
     }
   
   }
   ```

4. 测试代码

   ```Java
   public class Test {
      public static void main(String[] args) {
          //真实对象
         	Host host = new Host();
          //定义代理对象的调用处理程序类对象
          ProxyInvocationHandler pih = new ProxyInvocationHandler();
          pih.setTarget(Host); //设置要代理的对象
          UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
          proxy.rent();//通过代理类实现rent方法
     }
   }
   ```
   
5. [实现原理](https://blog.csdn.net/u014473112/article/details/88955944)



**动态代理优点**

* 所有静态代理的优点
* 一个动态代理可以代理多个类，代理的是接口！即代理了所有实现该接口的类

---

## AOP实现

**什么是AOP**

​	面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术

![](C:\Users\yangyim\Pictures\snipaste\640.png)



**[基本概念](https://blog.csdn.net/changudeng1992/article/details/80625134)**

​	[aop详细讲解](https://zhuanlan.zhihu.com/p/25522841)

**配置环境**

​	导入依赖

```xml
<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
<dependency>
   <groupId>org.aspectj</groupId>
   <artifactId>aspectjweaver</artifactId>
   <version>1.9.4</version>
</dependency>
<!--测试依赖-->
 <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
</dependency>
```

**第一种织入方式**：通过spring API实现

1. 编写业务接口

   ```Java
   public interface UserService {
   
      public void add();
   
      public void delete();
   
      public void update();
   
      public void search();
   
   }
   ```

2. 接口实现类

   ```Java
   public class UserServiceImpl implements UserService{
   
      @Override
      public void add() {
          System.out.println("增加用户");
     }
   
      @Override
      public void delete() {
          System.out.println("删除用户");
     }
   
      @Override
      public void update() {
          System.out.println("更新用户");
     }
   
      @Override
      public void search() {
          System.out.println("查询用户");
     }
   }
   ```

3. 编写一个Log增强类并添加前置增强；编写一个afterLog增强类并后置增强方法

   ```Java
   // Log增强类
   public class Log implements MethodBeforeAdvice {
   
      /**
      * before：内置前置增强方法
      * method : 实现类反射的Mathod类，可操作方法
      * objects : 被调用的方法的参数
      * Object : 实现类对象
      */
      @Override
      public void before(Method method, Object[] objects, Object o) throws Throwable {
          System.out.println( o.getClass().getName() + "的" + method.getName() + "方法被执行了");
     }
   }
   // AfterLog增强类
   public class AfterLog implements AfterReturningAdvice {
      /**
      * afterReturning：内置后置增强方法
      * returnValue 返回值
      * method被调用的方法
      * args 被调用的方法的对象的参数
      * target 被调用的目标对象
      */
      @Override
      public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
          System.out.println("执行了" + target.getClass().getName()
          +"的"+method.getName()+"方法,"
          +"返回值："+returnValue);
     }
   }
   
   ```

4. 编写配置文件：注意导入aop约束。需要学习**[execution表达式](https://www.cnblogs.com/sjqq/p/10247085.html)**

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/aop
          http://www.springframework.org/schema/aop/spring-aop.xsd">
   
      <!--注册bean-->
      <bean id="userService" class="com.kuang.service.UserServiceImpl"/>
      <bean id="log" class="com.kuang.log.Log"/>
      <bean id="afterLog" class="com.kuang.log.AfterLog"/>
   
      <!--aop的配置-->
      <aop:config>
          <!--切入点 需要在那个地方的前后插入增强方法-->
          <aop:pointcut id="pointcut" expression="execution(* com.kuang.service.UserServiceImpl.*(..))"/>
          <!--执行环绕; advice-ref执行方法 . pointcut-ref切入点-->
          <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>
          <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>
      </aop:config>
   
   </beans>
   
   ```

5. 测试

   ```Java
   public class MyTest {
      @Test
      public void test(){
          // 获取配置信息
          ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
          // 获取Bean对象
          UserService userService = (UserService) context.getBean("userService");
          userService.search();
     }
   }
   ```

6. **AOP思想**：

   ​	将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 

----

**第二种织入方法**：自定义类来实现Aop，更容易理解，但是功能不如前者完备

1. 自定义切入类

   ```Java
   public class DiyPointcut {
   
      public void mybefore(){
          System.out.println("---------方法执行前---------");
     }
      public void myafter(){
          System.out.println("---------方法执行后---------");
     }
      
   }
   ```

2. 编写配置文件

   ```Java
   <!--第二种方式自定义实现-->
   <!--注册bean-->
   <bean id="diy" class="com.kuang.config.DiyPointcut"/>
   <bean id="userService" class="com.kuang.service.UserServiceImpl"/>
   
   <!--aop的配置-->
   <aop:config>
      <!--切入面diy-->
      <aop:aspect ref="diy">
          <!-- 定义切入点-->
          <aop:pointcut id="diyPonitcut" expression="execution(* com.kuang.service.UserServiceImpl.*(..))"/>
          <!-- 切入点diyPonitcut，前置增强方法名mybefore-->
          <aop:before pointcut-ref="diyPonitcut" method="before"/>
          <aop:after pointcut-ref="diyPonitcut" method="after"/>
      </aop:aspect>
   </aop:config>
   ```

---

**第三种织入方式**：使用注解实现

```Java
@component //注册Bean
@Aspect //标明为切入面
public class AnnotationPointcut {
    
    // 前置通知
   @Before("execution(* com.kuang.service.UserServiceImpl.*(..))")
   public void before(){
       System.out.println("---------方法执行前---------");
  }

   @After("execution(* com.kuang.service.UserServiceImpl.*(..))")
   public void after(){
       System.out.println("---------方法执行后---------");
  }

    // 环绕通知，使用自定义的mypoint替代切入点表达式
   @Around("mypoint()")
   public void around(ProceedingJoinPoint jp) throws Throwable {
       System.out.println("环绕前");
       System.out.println("签名:"+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println("环绕后");
       System.out.println(proceed);
  }
    
   // 指定切入点，便于增强方法引用
   @pointcut("execution(execution表达式)")
   //Point签名，不需要实现，相当于切入点配置中的id，便于后续引用,即可以使用该方法代替execution表达式
   public void mypoint(){}
}
```

