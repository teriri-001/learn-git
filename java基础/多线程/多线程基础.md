## 创建方式

1. **继承Thread类（不建议使用）**

   1. 重写`run()`方法，编写线程执行体

   2. 创建线程对象，调用`start()`方法开启线程

      ```java
      // 创建线程类
      public class testThead extends Thread{
         //编写线程执行体
          public void run(){
              system.out.println("线程执行体");
          }
      }
      public static void main(String[] args){
          // 创建一个线程对象
          testThread tsd = new testThread();
          // 使用线程对象开启该线程,等待cpu调度执行
          tst.start();
      }
      ```

   3. **不建议使用：避免OOP（面向对象）单继承局限性**

2. **实现Runnable接口（建议使用）**

   1. 重写`run()`方法，编写线程执行体

   2. 使用Thread类创建线程对象，并将实现类的对象实例作为构造函数参数

   3. 使用线程对象调用`start()`方法开启线程

      ```Java
      // 创建线程类,实现Runnable接口
      public class testThead implements Runnable{
         //编写线程执行体
          public void run(){
              system.out.println("线程执行体");
          }
      }
      public static void main(String[] args){
          // 实例化一个实现类对象
          testThead thd = new testThead();
          // 使用Thread类创建一个线程对象
          Thread thr = new Thread();
          // 使用线程对象开启该线程,代理
          thr.start(thd);
      }
      ```

   4. **推荐使用：避免单继承局限性，方便同一个对象被多个线程使用（多个线程共享同一个数据）**

3. **实现Callable接口**

   1. 优点：可以抛出异常，有返回值

   ```Java
   // 创建线程类，实现Runnable接口，需要返回值
   public class testThead implements Callable<boolean>{
       // 重写call方法，编写线程执行体
       public void call(){
           system.out.println("线程执行体");        
       }
   }
   // 抛出异常
   public static void main(String[] args) throws execeptionxxx
   {
      // 创建线程对象
       testThread thd1 = new testThread();
       testThread thd2 = new testThread();
       // 创建执行服务
       ExecutorService ser = Executors.newFixThreadPool(2);
       // 提交执行,返回值result1、2
       Future<boolean> result1 = ser.submit(thd1);
       Future<boolean> result2 = ser.submit(thd2);  
       // 获取结果,需要抛出异常
       boolean res1 = result1.get();
       boolean res2 = result2.get();
       // 关闭服务
       ser.shutdownNow();
   }
   ```

   

## 并发问题

1. **初识并发**

   1. [火车票问题](https://www.cnblogs.com/upyouth/p/5721820.html)

      ```Java
      /**
      * 问题：有一定数量的火车票，有多个窗口同时售卖
      * 思路：一个对象被多个线程使用,需要使用Runnable()接口实现
      * 发现问题：多个线程操作同一个对象，线程不安全
      */
      // 建立一个线程类
      public class ticketThread implements Runnable(){
          // 票数
          private int ticketNums = 100;
          public void run(){
              // 使每个线程能够循环售票
              while(true){
                  if (ticketNums < 0)
                      break;
                  // 模拟延时，避免线程太快看不出现象
                  try{
                      Thread.sleep(200); //200ms
                  } catch(Exception e){
                      e.printStackTrace();
                  }
                  // 买票
                  system.out.println(Thread.currentThread.getName()+"买了"+ticketNums--);
              }
          }
      }
      public static void main(String[] args){
          // 实例化一个实现类对象
          testThead thd = new testThead();
          // 创建多个线程执行
          new Thread(thd,"线程名1").start();
          new Thread(thd,"线程名2").start();
          new Thread(thd,"线程名3").start();	
      }
      ```
   
2. **线程同步**

   1. 解决并发问题，即同一个对象被多个线程同时操作
   2. 同步场景：
      * 多个线程访问同一个对象
      * 存在线程想要**修改**该对象
   3. 本质
      * 线程同步本质是一种**等待机制**
      * 即让多个需要同时访问的线程进入**对象等待池**，形成队列，前一个线程使用完毕，下一个线程才可以再使用
   4. 实现思路：**队列+锁（synchronized）**
   5. 同步方法及同步块
      1. 同步方法：即在方法上添加`synchronized`
      2. 同步代码块：同步需要修改的部分代码
      3. 两者的锁：同步方法的锁是该类的**class类对象**；同步代码块的锁是**线程要修改的变量**
   6. 缺点：
      1. 效率降低
      2. 性能降低
   
3. **死锁**

   1. 概念：
      * 多个线程互相抱着对方需要的资源不释放，让后形成僵持
   2. 产生死锁的四个必要条件
      * 互斥条件：一个资源只能被一个进程使用
      * 请求与保持条件：
      * 不剥夺条件
      * 循环等待条件
      * 以上条件破坏其一即可避免死锁

4. **lock锁**

   ```java
   /**
   * 问题：有一定数量的火车票，有多个窗口同时售卖
   * 思路：一个对象被多个线程使用,需要使用Runnable()接口实现
   * 使用Lock实现同步解决并发问题
   */
   public class ticketThread implements Runnable(){
       // 定义锁,ReentrantLock可重复锁
       private final ReentrantLock lock = new ReentrantLock();
       private int ticketNums = 100;
       public void run(){
           while(true){
               try{
                   // 加锁
                   Lock.lock();
                   if (ticketNums < 0)
                   break;
               	try{
                   	Thread.sleep(200); 
               	} catch(Exception e){
                   	e.printStackTrace();
               }
               system.out.println(Thread.currentThread.getName()+"买了"+ticketNums--);
               } finally{
                   // 释放锁
                   Lock.unlock();
               }
           }
       }
   }
   public static void main(String[] args){
       // 实例化一个实现类对象
       testThead thd = new testThead();
       // 创建多个线程执行
       new Thread(thd,"线程名1").start();
       new Thread(thd,"线程名2").start();
       new Thread(thd,"线程名3").start();	
   }
   ```

   

## [代理](https://www.cnblogs.com/cC-Zhou/p/9525638.html)

代理模式给某一个对象提供一个代理对象，并由代理对象控制对[原对象的引用](https://blog.csdn.net/flybone7/article/details/80544484)通俗的来讲代理模式就是我们生活中常见的中介

1. **静态代理实现总结**
   1. 真实对象和代理对象都要实现同一个接口
   2. 代理对象要代理真实

## 线程状态

1. 线程存在五大状态：包括开始状态，就绪状态，运行状态，阻塞状态，结束状态
2. 常用线程方法
   * `setPriority(int newpriority)`：更改线程的优先级，增加被CPU选中的比率
   * `sleep(time)`：
     * 让线程阻塞指定毫秒数，然后进入就绪状态
     * `sleep()`方法存在异常，需要抛出
     * 可以用来模拟网络延时，倒计时等操作
   * `stop()`：
     * 停止一个线程，
     * **不建议用方法停止线程，而是使用标志位进行停止线程，即在线程执行体外编写一个标志位转换方法
   * `yield()`:
     * 让当前正在执行的线程暂停，但不阻塞，即让cpu重新进行线程调度。
   * `join()`：停止当前正在执行的进程，让join进程执行
   * `state()`：观测线程当前状态
3. 守护线程：线程分为用户线程和守护线程（后台线程）

## 线程通信

1. **生产者消费者问题**

2. 常用方法：

   * `wait([time])`：当前线程等待，直到被其他线程唤醒，与sleep区别在于该发放会释放锁。
   * `notify()`：唤醒一个处于等待状态的线程
   * `notifyAll()`：唤醒所有调用`wait()`方法的线程（同一个对象）

3. **管程法**

   ```java
   /**
   *利用一个缓冲区解决生产者消费者问题
   *角色：生产者，消费者，产品，缓冲区
   */
   //生产者
   class conducter extends Thread{
       
   }
   //消费者
   class consumer extends Thread{
       
   }
   // 产品
   class something {
       //get set方法
   }
   // 缓冲区
   class syncContainer{
       //容器大小
       
       //生产者生产产品
       
       //消费者消费产品
   }
   ```

4. **信号灯法**

   ```java
   /**
   *通过一个标志位解决生产者消费者问题
   */
   ```

## 线程池

1. **背景**：

   1. 线程的经常创建和销毁，消耗大量的资源，并发情况下，影响程序性能

2. **思路**：

   1. 提前创建多个线程，放入线程池中，使用时直接获取，使用完放回池中。
   2. 从而可以避免重复的创建和销毁，实现重复利用

3. **优点**

   1. 提高响应速度（减少了创建新线程的时间）
   2. 降低资源消耗（不需要每次都重新创建新线程）
   3. 便于线程管理

4. **ExecutorService**：真正的线程池接口，常用子类**ThreadPoolExecutor**

   1. `void execute(Runnable command)`：执行任务/命令，没有返回值，一般用于执行Runnable接口的线程

   2. `void Future<T> submit(Callable command)`：执行任务/命令，有返回值，一般用于执行Callable接口的线程

   3. `void shutdown()`：关闭连接池

   4. `Executors接口`：用于创建线程池

      ```Java
      /**
      *使用线程池，实现Runnable接口的线程
      */
      // 线程类
      class myThread implements Runnable{
          // 重新run方法
          public void run(){
              
          }
      }
      // 测试线程池
      public class testPool{
          // main方法
          public static void main(String[] args){
              // 创建线程池，参数为池子大小
              ExecutorService exec = Executors.newFixedThreadPool(10);
              // 将线程类放入线程池中,并执行线程类的run方法
              exec.execute(new myThread());
              exec.execute(new myThread());
              // 关闭连接
              exec.shotdown();
      }
      ```

      





