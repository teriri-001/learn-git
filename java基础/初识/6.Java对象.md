## 类和对象的关系
1. 类是对生活中事物的抽象描述，描述其属性和行为

2. 对象就是类的实例，存放在堆内存中

## 类的定义及生成对象
1. 使用关键字`class`定义一个类

2. 使用`new`关键字创建类的对象，创建的对象存放在堆中，变量名位于栈中，存放堆中的地址。

## 成员变量和局部变量
1. 成员变量作用与整个类中

2. 局部变量作用于函数或者语句中

3. 成员变量在堆内存中，局部变量存在于栈内存中

## 匿名对象
1. 当对对象的`方法`只`调用一次`时，可以使用匿名对象，优点是比较简化

2. 可以将匿名对象作为实际参数进行传递

3. 语法格式
    * `new 类名（参数列表）;`

## 封装
1. 隐藏对象的属性和实现细节，仅对外提供公共访问方式。

2. 封装原则
    * 隐藏不需要对外提供的内容
    * 把属性都隐藏，提供公共方法对其访问。

3. 封装方法(private)
    * 使用私有修饰符`private`对成员变量、函数进行封装
    * 私有成员只能在本类中被访问,对于外界包括创建的对象引用都是无法访问的
    * 使用方法对外提供对私有成员的访问，方法存放在方法区

## 构造函数
4. 特点
    * 函数名与类名相同
    * 不用定义返回值
    * 构造函数在对象建立时会被调用，所以构造函数可以用于给对象的一些属性进行初始化
    * 类中没有定义构造函数时，系统会自动给该类添加一个空参数的构造函数

5. 构造函数与普通函数差别
    * 构造函数在对象建立时运行且构造函数只运行一次，普通函数调用时运行
    * 构造函数主要用于给对象初始化，定义一些事物存在就具备的一些特性或行为
    
6. 构造代码块
    * 用于给对象进行初始化
    * 对象一建立就运行，优先于构造函数
    * 构造代码块给所有对象初始化，定义不同对象所共同具有的初始化内容

## this关键字
1. 局部变量和成员变量重名时，系统认为为局部变量，可以使用this解决

2. this关键字
    * this指代本类中当前正在调用函数的对象

3. this关键字的使用
    * 当定义类中的方法时，函数内部需要调用函数所在对象时，使用this指代这个对象
    * 构造函数间的调用只能使用this,且只能放在第一行：`this(参数)`
    * 静态成员、静态方法中不能用this和super关键字。即使指向静态成员也不行，（因为this代表对象的引用，而静态方法属于类的，即静态方法先于对象存在）

## static关键字
1. 用法
    * 静态修饰符，用于修饰类中的成员
    * 静态成员除了被对象调用外，还可以直接被类名调用
    * 当使用类名调用时，若没有实例的对象，则指向的是类定义时的值；若已经实例了对象则指向当前所定义的对象。
    * 常把各个对象所共有的属性设置为静态

2. 内存结构
    * 静态数据存放在`方法区`

3. 特点
    * 随着类同一时间被写入内存，先于对象存在；也随着类的消失而消失。
    * 静态变量也称为类变量；其他变量也称为实例（对象）变量
    * 静态成员独立于该类的任何对象，即该成员不属于任何一个实例对象，而是被实例对象所共享。

4. 使用注意事项
    * 静态方法只能访问静态成员，因为静态先于对象存在
    * 静态方法中不可以定义`this,super`关键字，因为该关键字是对象的引用，而静态先于对象存在。

5. main函数
    * public: 代表最大访问权限
    * static：代表主函数随着类的加载便存在
    * void： 没有具体返回值
    * main：非关键字，但可以被jvm识别
    * （String[] args): 参数，jvm调用主函数时会向其传值。
    * 主函数格式固定，jvm识别

6. 静态变量场景
    * 各个对象中所共有的`数据`时使用静态所修饰，对象特有的数据定义成非静态

7. 静态函数场景
    * 当函数不会访问对象的特有数据时，则定义为静态的

## 建立工具类
1. 工具类定义
    * 将一些共用的功能封装成工具类，提供给其他类使用
    * 工具类内部函数常设为静态，不需要传入数据的也可以进行私有化
    * 为了调用严谨，将工具类的构造函数私有化，避免使用时建立对象。

2. 工具类帮助文档（Javadoc）
    * 在工具类中使用文档注释符进行说明：简介、功能、用法等(使用@)
    * 使用`javadoc`命令：`javadoc -d 存放目录`

## 静态代码块
1. 写法
```
    static{

    }
```
2. 用于给类进行初始化，在类加载时运行

## 对象执行过程
1. 初始化过程
    1. 先找到对象所在.class文件，并加载到内存中
    2. 执行静态代码块，给类进行初始化
    3. 在内存中开辟空间，分配内存地址
    4. 在堆中建立对应属性，并进行默认初始化
    5. 对属性进行显示初始化
    6. 构造代码块初始化
    7. 构造函数初始化
    8. 将地址赋给栈中的变量
2. 对象调用过程

## 单例设计模式
1. 解决问题：
    * 解决一个类在内存中只存在一个对象

2. 解决思路
    * 为避免其他程序过多的建立对象，应先禁止其他程序建立该类对象
    * 为了使用，选择自己建立一个对象
    * 为了访问，还需对外定义一些访问方式

3. 实施方法
    * 将构造函数私有化，使其他程序违法创建对象
    * 在类中创建一个本类对象
    * 提供一个方法，其他程序调用时返回该对象
```java 
    //饿汉式，先创建对象,开发一般使用饿汉式，安全和简单
    class single{
        // 将构造函数私有化，使外部无法通过new创建对象
        private single(){};
        // 自己创建一个对象，因为对外函数是静态的，所以设为静态，同时一般将成员属性设为私有
        private static single object = new single();
        //  需要被外部引用，所以设为静态，返回
        public static single getInstance(){
            return object；
        }
    }
    //懒汉式，调用方法时才创建对象
    private static singel obj = null;
    private single(){};
    public static single getInstance(){
        if(obj == null){
            obj = new single();
        }
        return obj;
    }

```

## 继承
1. 继承的优点
    * 提高代码复用性
    * 使类与类之间产生了关系，故而产生了多态的特性

2. 继承关系建立原则
    * 使用关键字`extends`建立继承关系
    * 必须是类与类之间有所属关系才可以继承
    * 类与类之间的共性可以提取出来建立`基类`,并与类建立继承关系。

2. 子类对父类的访问权限
    * 父类的private权限，子类无法访问
    * 父类的friendly权限（默认权限），当子类与父类在同一个包中则可以访问，否则无法访问
    * 父类的protected权限，子类可以访问
    * 父类的public权限，可以访问
    * 子类可以扩大基类的访问权限（子类能访问时），但是无法缩小基类的访问权限
3. 单继承
    * Java只支持单继承，不支持多继承，使用多实现体现多继承（即一个子类只能有一个基类，而一个基类可以派生多个子类）
    * Java支持多层继承，子类 --> 父类 -->父类

4. 使用继承体系的功能
    * 通过了解顶层的共性功能，就可以知道该体系基本功能
    * 具体调用时，要创建最底端子类的对象，子类包含的功能最全

5. 聚合关系
    
* 如球队和球员，部分和聚合之间的生存期无关。
    
6. 组合关系
    
* 如人和手，删除了组合，同时也就删除了部分
    
7. 继承关系出现后子父类变量成员特点
    * 子父类中出现非私有同名变量时，父类变量被屏蔽，因为变量前省略了`this`关键字，可以使用`super`关键字指代父类。（当不同名时，子类中两者指向同一个对象---多态）
    * 加载方式改变
        1. 堆内存的对象空间中；同时存在父子类的变量
        2. 方法区先加载父类的方法，再加载子类的方法
    * this指代本类对象的引用，super表示父类对象的引用，super的特性与this完全一致。

8. 继承关系出现后子父类函数的特点
    * 子父类的成员函数出现同名时，子类函数运行，称之为`覆盖（重写）函数的特性其二（其一为重载）`
    * 当从父类沿袭的功能内容不适用子类情况时，可以使用函数重写的特性，保留功能特性，而重写功能内容。
    * 注意事项
        1. 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败
        2. 静态只能覆盖静态（内存加载先后问题）
        3. 存在四种权限（1. 私有 ，2 公有 ，3 默认（介于两者之间，C++中称为friendly）4. 受保护（protected）
        4. 对于父类的私有权限，子类无法覆盖（因为无法继承私有权限）

9. 继承关系中子父类构造函数的特点（子类实例化过程）
    1. 访问父类的空参数构造函数
        * 原因在于`每一条子类`的构造函数中第一行都隐藏了一条语句`super();`

    2. 接着访问子类的构造函数

    3. 当父类中没有空参数的构造函数（即添加了一个有参数的构造函数时），需要在子类中显示的添加语句`super(参数)`

    4. 原因
        * 子类对象建立时，可以访问父类的数据，所以需要查看父类对其数据的初始化方式,故需要父类进行初始化。

10. final关键字特点
    * 作为一个修饰符可以修饰类、函数、变量
    * 被final修饰的类不可以被继承，可以用于避免被子类重写功能
    * 被final修饰的方法不可以被子类重写
    * 被final修饰的变量是一个常量，不可以再赋值。final既可以修饰成员变量，又可以修饰局部变量。（常量都字母大写，用_进行连接）
    
11. 抽象类（定义共同存在的基本功能）
    * 抽象类的特点
        1. 抽象方法一定定义于抽象类中
        2. 使用`abstract`定义抽象类、抽象方法，其中抽象方法没有方法体；
        3. 抽象类不可以使用`new`创建对象
        4. 子类继承抽象类时，必须对抽象类中所有的抽象方法进行重写，否则子类也成为一个抽象类。
        5. 抽象方法来源：多个类出现相同功能，但是函数主体部分不同，可以进行向上抽取，但是只抽取功能的定义，功能主体需要子类复写。（对于功能定义和主体部分都相同的情况，直接全部抽取）

    * 与普通类的区别
        * 抽象类无法实例化
        * 抽象类多了抽象函数

12. 模板方法设计模式
    * 应用场景
        * 在定义功能时，功能的一部分是确定的，一部分不确定，且确定的部分在使用不确定的部分，那么这时就将不确定的部分暴露出去由子类重写，确定部分使用final关键字避免重写。
    * 代码举例
    ```
    abstract class GetTime
    {
        //确定部分
        public final void getTime()
        {
            long stract = System.currentTimeMillis();
            runcode();//不确定部分
            long end = System.currentTimeMillis();
            System.out.pringln("运行时间："+(end - start));
        }
        //不确定部分
        public abstract void runcode();
    }
    class subtime extends GetTime{
        //重写不确定部分
        public void runcode(){
            代码主体；
        }
    }
    //总结，将代码中确定部分使用final封装，将不确定的部分剥离出来由子类去重写功能主体。
    ```

## 接口（定义扩展功能）
1. 接口的定义
    * 当抽象类中的`方法`都是抽象的，那么该类可以使用接口的形式来表示
    * 使用关键字`interface`来定义一个接口
    * 接口用于程序功能的扩展。对于总体来说不是共性的，但是部分拥有。则可以设计为接口，让部分实现。

2. 定义接口时的格式特点
    * 接口中常见定义：常量、抽象方法；
    * 成员都有固定修饰符，少写系统会补全。
        1. 常量：public static final
        2. 方法：public abstract

3. 接口的特点
    * 接口无法创建对象
    * 接口之间存在继承关系，且存在多继承。
    * 接口需要子类来实现，使用`implements`关键字定义。
    * 子类对接口中所有抽象方法全部重写后，子类才可以实例化，否则子类为抽象类。
    * 接口可以对类多实现。即一个类可以同时实现多个接口（`class test implements interA,interB{}`),因为接口中的函数没有主体，由子类自己定义，不会产生冲突。

## 多态
1. 概念
    * 理解为事物存在的多种体现形态（动物：猫，狗）
    * 多态的引用提高了代码复用性

2. 多态的体现
    * 父类的引用变量指向了自己的子类（即父类的引用可以接收自己的子类）
    * 写法举例：`animal x = new cat();`,详见`doly.java`
    * 接口型引用指向了自己的子类对象

3. 多态-转型
    * `animal x = new cat();` 
        1. 存在类型提升，子类向上转型
        2. 存在无法调用子类特有方法的情况，使用时需要向下转型
    * `cat c = (cat) x` ，即通过强制类型转换转成子类类型
    * 不能将父类转换为子类（多态情况可以，因为一直都是子类对象做变化）

4. 多态中成员的特点
    * 非静态情况下
        1. 编译时期，参阅引用型变量所属（父类）中是否有调用的方法。有则编译通过，没有则失败
        2. 运行时期，参阅对象所属类中是否有调用的方法（即运行子类）
    * 静态情况下，类加载便已存在，则谁调用执行谁的方法。

## object类
1. 概述
    * object类是类层次结构的根类，所有对象的直接或者间接父类
    
2. equals()方法
    * object类中定义的对象比较方法，比较地址值，可以重写。

3. tostring()方法
    * 转换为字符串并返回

## 内部类
1. 内部类访问规则
    * 定义在另一个类里面的类称为`内部类`。
    * 内部类可以直接访问外部类的成员。
    * 外部类访问内部类需要建立内部类对象
    * 其他类访问内部类需要使用全称定义对象：`outer.inner object = new outet().new inner();`
    * 外部类变量与内部类变量同名，使用外部类变量需要使用`outer.this.element`
    * 内部类定义在局部时（函数中）
        1. 不可以被成员修饰符修饰
        2. 可以访问外部类中的成员，但是局部中的变量只能访问`final`修饰的局部变量。
2. 静态内部类
    * 内部类可以被修饰符（private 、 static）等修饰，进行封装。
    * 内部被静态修饰时，具有静态的特性，具有访问访问局限,
    * 当内部类中定义了静态成员，则该内部类必须是静态的。
    * 外部类直接使用静态类的类名访问静态内部类的类成员。
3. 使用场景
    * 描述事物时，事物内部还有事物，为体现联系则定义内部类。
    * 当函数参数是一个接口，且接口实现的方法不多于3个时。可以定义匿名内部类。

4. 匿名内部类
    * 是内部类的简写格式
    * 定义匿名内部类的前提：
        1. 内部类必须是继承一个类或者实现接口
    * 定义格式：
    ```
    new absDemo<父类或接口对象>(){
        // 实现方法
        void show(){

        }
    }<匿名子类对象>.show()<调用的方法>;
    ```
    * 匿名内部类中定义的方法最好不要超过3个

## 异常机制
1. 异常概述
    * 程序`运行时`出现不正常情况
    * 由来：Java对不正常情况进行描述后的对象体现
    * Java对于严重的问题通过error类进行描述，一般不编写针对性代码进行处理；
    * Java对于不严重的问题通过exception类进行描述，可以使用针对性代码进行处理。
    * 处理异常时，能处理则处理，不能则抛出。
    * 出现的问题处理内部处理（catch即处理异常）的情况下，不需要再方法部分声明；否则一定要进行声明。

2. try-catch语句
    * Java定义的异常处理语句格式
    ```
    try{
        //需要被检测的代码；
    }
    catch(异常类 变量){
        //异常代码的处理方式
        //只处理自己的问题，抛出解决结果
    }
    finaly{
        //无论是否异常都一定会执行的语句
        //通常用于关闭资源
    }
    ```
3. 异常声明throws
    * 在功能上通过`throws`关键字声明该功能可能会出现问题。（抛出异常给Jvm）
    * 可以在功能执行语句进行异常的处理：使用如上格式

4. 多异常处理
    * 声明异常时，建议声明得更为具体（不声明为exception）
    * 多个异常声明时，使用逗号隔开。处理时使用相同多个catch语句处理。
    * 不存在同时出现多个异常，异常出现则程序停止。

5. 自定义异常
    * 项目中出现的特有问题，可以自定义异常
    * 定义方法：必须继承异常类`exception`。因为对象可抛性只在该体系中存在。
    * 自定义异常只能手动抛出：`throw new 自定义的异常`(定义了一个异常对象),然后进行抛出。
    * throw代表程序运行至该处结束，其后不能接执行语句。

6. runtimeException子类
    * 如果在函数内抛出该异常，函数上可以不用抛出声明，因为在运行时检测，编译时不检测。
    * 如果在函数上声明了该异常，调用者可以不用进行处理，该程序停止运行。
    * 自定义异常时，如果异常的发生导致无法继续运算，可以在定义时继承`runtimeException()`类。

7. 异常在子父类重写中的体现
    * 子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法只能抛出父类的异常或者该异常的子类或者不抛。（原则在于让父类能处理）
    * 子类出现其他异常时，只能在内部处理，不能抛出。
    * 如父类或者接口的方法中没有异常抛出时，子类也不能抛出任何异常，必须在内部进行异常处理。

8. 总结
    * 定义：异常是对问题进行描述，将问题进行对象的封装
    * 异常体系：throwable超类包含error和exception两种子类，其中exception存在特殊的runtimeException子类。
    * 异常体系特点：建立的对象可抛，即可被throw和throws关键字操作
    * throw和throws的特点：
        1. throw定义在函数内，用于抛出异常
        2. throws定义在函数上，用于抛出异常对象，多个用逗号隔开
        3. 当函数内有throw抛出异常，且未在函数内使用try处理，则必须要在函数上使用throws声明。其中runtimeException类不用进行声明。
        4. 如果声明了异常，且未在函数内处理，则由函数调用者进行异常处理，处理方式可try可throws。
    * 异常有两种：
        1. 编译时异常
        2. 运行时异常（编译时不检测）
    * 异常处理，三种异常处理格式中，只有使用catch处理的异常才被认为是处理过的异常。
    * 自定义异常：
        1. 定义的类继承Exception或RuntimeException类
        2. 用于将程序出现的特有问题进行封装
    * 异常处理原则：
        1. try和throws两种处理方式
        2. 当捕获到的异常处理不了时，可以在catch中继续抛出。
        3. 当异常处理不了，但不属于该功能的出现的异常，可以将异常转换后，抛出和该功能相关的异常

## 包（package）
1. 概述
    * 包名定义在代码第一行
    * 包名规范写法为全部小写，不能重复，建议使用url反写来定义包
    * 有了包之后类名全称为：包名.类名
    * 包也是一种封装。

2. 包与包之间的访问
    * 包与包之间要进行访问，被访问包中的类及其类的成员必须拥有足够大的权限（public修饰）
    * 不同包之间，子类可以访问父类中被protected权限修饰的成员
    * 类名前使用public权限修饰时，类名必须与java文件名一致，且一个文件中不能出现两个以上的公有类。

3. import关键字
    * 用于导入包中的类，便于类名简写（不用添加前缀包名）
    * 可以使用通配符`*`代表所有，建议不用。但是可以自动导包。

4. jar包
    * Java的压缩包