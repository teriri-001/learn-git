## 集合体系概述
1. 来源
    * 多个基本类型数据需要封装成类对象存储，而多个对象可以使用数组或集合类存储。

2. 数组和集合类的差别
    * 数组长度固定，但是集合的长度是可变的
    * 数组只能存储同一种类型对象，集合可以同时存储不同类型对象

3. 集合类的特点
    * 集合只用于存储对象
    * 集合的长度可变
    * 集合可以同时存储不同类型对象

4. 集合概述
    * 容器向上抽取的过程中形成集合接口`(Collection)`
    * 常用子接口：`list`和`set`,子接口向下有各种不同的容器
        * list集合中：元素是有序的，元素可重复存储，因为为建有索引
        * set集合中：元素是无序的，不可以重复，没有索引
    * 每一个容器有自己的数据存储方式，称之为`数据结构`
    * 集合在堆内存中开辟空间，其中存放的是各个对象在堆内存中的地址

## 集合（Collecction)中的共性方法
1. 常用方法
    * `add(元素)`:添加元素；
    * `addAll(集合)`:向集合中添加集合
    * `clear()`：删除所有元素
    * `remove(元素名)`:移除一个元素
    * `removeAll(集合)`:移除与另一集合相同的元素
    * `size()`:返回长度
    * `toArray(集合)`:集合转换为数组
    * `retainAll(集合)`:返回两集合的交集

2. 遍历集合
    * 直接使用集合名，将以数组模式输入所有元素，但是不能操作
    * `iterator()`:迭代器
        1. 该方法返回集合中的一个iterator对象，该对象中存在访问元素的方法
        ```
        //迭代器遍历集合举例
       ArrayList col = new ArrayList();
        col.add("public");
        col.add("static");
        col.add("void");
        col.add("main");
        // 迭代方式1，循环结束后迭代器还占用内存
        Iterator ite = col.Iterator();
        while(it.hasNext())
        {
            System.out.println(ite.next());
        }
        // 迭代方式2,迭代器为局部变量，循环结束后清理
        for(Ierator ite = col.Iterator(); ite.hasNext();)
        {
            System.out.println(ite.next());
        }
       ```

## List集合中的特有方法
1. 即可以操作指定角标元素的方法

2. 增加
    * `add(index,element)`:在指定位置添加元素
    * `addAll(index,collection)`:添加集合

3. 删除
    * `remove(index)`:删除指定位置元素

4. 修改
    * `set(index,element)`:修改指定位置的元素

5. 查询
    * `get(index)`:根据角标获取元素，可以通过该方法变量list集合
    * `indexOf(object)`:返回对象的位置
    * `subList(start,end)`:获取指定区域的子集合
    * `listIterator()`:列表迭代器
6. listIterator列表迭代器
    * `在迭代过程中，不可以通过集合对象的方法操作集合中的元素`
    * 原来的迭代器操作元素时会出现并发访问异常（即迭代器和集合引用同时访问集合对象），存在局限性
    * 列表迭代器在原来迭代器的基础上扩充了更多操作集合的方法
        1. 包括集合的增删改查，反向遍历等

## list集合具体对象的特点
1. 概述
    * 由于底层的数据结构不一致故划分为多个对象实体

2. ArrayList对象
    * 底层数据结构使用`数组结构`，线程不同步
    * 查询、更改元素速度快，但是增加、删除操作插入速度慢

3. LinkedList对象
    * 底层数据结构使用`链表结构`
    * 查询、更改速度慢，但是增加、删除操作速度快
    * 特有方法（arraylist没有）
        1. 从头部或尾部添加：`addFirst()`或`addLast()`，被`offer...()`替代
        2. 获取头部或尾部元素：`get...()`,为空会抛异常，所以被`peek...()`替代
        3. 获取头部或尾部元素并删除：`remove...()`,为空会抛异常，所以被`poll...()`替代 
4. vector
    * 底层是数组数据结构，与arraylist相同，实现是线程同步的
    * 效率低，已被arraylist替代。
    * 枚举是vector特有取出方式。

## set集合
1. 元素是无序的（即存入和取出的顺序不一定一致），元素唯一（不可重复）
    * 顺序不一致指：如存入（1 、2 、3 、4） ，而取出的可能是 （4 、1 、3 、2）

2. set集合和collection集合的方法是一致的

3. 没有建立对数据的索引

4. 自建类的对象存入set集合时，都需要重写`hashcode()`和`equals()`方法

## set集合常见子类
1. HashSet对象
    * 底层数据结构是`哈希表`，线程是非同步的
        1. 哈希表中存放对象地址值对应的哈希值，并按照计算的哈希值顺序存放。
        2. 保证元素唯一：判断`hashcode()`返回值是否相同，如果哈希值相同会调用equals方法，比较两者的值，如果相等后者则被剔除。
    * `自定义对象的存储`：

        1. 可以在对象类中重写`hashcode()`函数，设置返回哈希值，即哈希表中存储位置。再重写equals方法，确定比较原则。

        2. 重写`hashcode()`:

            ```java
            /*
            * 字符串有自己的哈希方法，对于数字可以直接返回
            * 同时存在字符串和数字，可以字符串调用哈希方法后再与数字相加
            * 原则是尽量保证哈希值唯一
            * */
            public class person{
                private String name;
                private int age;
               @Override
                public int hashcode(){
                    return name.hashcode()+age;
                }
            }
            ```

        3. 重写`equals()`

            ```java
            public class person{
                private String name;
                private int age;
                @Override
                public Boolean equals(Object obj){
                    // 使用==显示判断比较对象是否是同一对象,判断的是引用地址
                    if (this == obj){
                        return true;
                    }
                    // 比较对象是否为空，是则必须返回false
                    if (obj == null){
                        return false;
                    }
                    // 判断比较类型是否合法,子父类之间为true
                    if (!(obj instanceof person)){
                        return false;
                    }
                    // 强制转换，避免子父类问题
                    person other = (person)obj;
                    return this.name.equals(other.name) && (this.age == other.age)
                }
            }
            ```

2. TreeSet对象
    * 底层数据结构是`二叉树`
      
        1. 保证元素唯一：依靠`compareTo（）`方法的比较结果保证唯一性，如果相等则后者被剔除。（`第一种方式`,原理是让对象具备比较性，通过对象重写`compareTo()`方法）
        
    * 可以对set集合中的元素进行排序，按照ASCII码的值进行排序

    * `自定义对象的存储`:
      
        1. 需要实现对象重写比较接口`comparable`中的`compareTo()`方法,让对象具备比较性。
        2. 重写`compareTo()`
            * 大于则返回正数，小于返回负数，等于返回0;
            * 注意主要条件相等的情况下，要添加次要比较条件
            * 对于字符串的比较可以使用字符串自带的`compareTo()`方法
        
    * treeset实现排序原理
        1. 使用的是二叉排序树的原理
        2. 即先入为根节点，小于则为左子树，大于则为右子树
        3. 输出时使用前序遍历方法遍历该二叉树即可
        4. 特殊使用：（输入与输入相同）
            *  使`compareTo()`方法一直返回正数，
            *  使`compareTo()`方法一直返回负数，则可实现倒序输出
        
    * 保证TreeSet对象具有唯一性`第二种方式`（常用）

        ```Java
        /*
        * 让集合具备比较性，通过定义comparator接口的比较器
        * 实现方法：
        * 1. 新建比较器类实现`comparator`接口，重写其`compare()`方法
        * 2. 在创建`TreeSet`对象时，将接口的对象作为参数传递给其构造函数
        * 3. 可以在该类中修改比较规则：小于返回-1（负数）;等于返回0;大于返回1（正数）
        * 也可以在sort()方法中添加比较器对象，实现自定义排序
        **/
        public class ComparatorDemo {
            public static void main(String[] args) {
            Set<person> people = new TreeSet<>(new myComparator());
                people.add(new person("sinon",18));
                people.add(new person("megumi",22));
                people.forEach(elm -> System.out.println(elm));
            }
            // 因为主函数是静态的所以使用静态内部类，实现了comparator接口
            public static class myComparator implements Comparator<person> 	   {
                @Override
                public int compare(person o1, person o2) {
                    // 如果age相等，则比较name
                    if (o1.getAge() == o2.getAge()){
                        if (o1.getName().equals(o2.getName())){
                            return 0;
                        }
                        // 使用string类型自带compareto方法比较大小
                        return o1.getName().compareTo(o2.getName());
                    }
                    return o1.getAge()-o2.getAge();
                }
            }
        }
        ```
    
    * 当唯一性的两种方法都实现时，第二种接口比较器方法优先。且日常使用中第二种方式使用更频繁

## 泛型（新特性）
1. 泛型概述
    * 用于解决集合中的安全问题，是一种类型安全机制
1. 安全问题
    * 集合在定义是未声明所存储的数据的类型，存在安全隐患（如添加了一个数字，自动装箱后成为Integer包装类。如果对集合强制类型转换成字符串对象，则运行报错，但是能编译通过）
2. 解决方法：
    * 在集合定义时，使用尖括号声明集合存储的类型：`ArrayList<string> ary = new ArrayList<string>()`
    * 声明之后，往集合中添加非字符串类型对象时，则编译不通过
    * 泛型的声明避免了强制类型转换
    * 注意：
        1. 迭代器定义时，也应该声明存储的数据类型，否则编译不通过
3. 泛型的好处
    * 将运行时期出现的问题，转移到了编译时期出现。
    * 避免了使用过程中的强制类型转换（类型统一了）
4. 使用注意事项
    * 格式：通过`<>`来定义要操作的引用数据类型

## 泛型类
1. 当类中要操作的数据类型不确定时
    * 早期，通过定义`object`来完成扩展
    * 泛型出现后，使用泛型类完成扩展

2. 实现方式
    ```
    calss 类名<任意标识符(type)为例>{
        // 使用type声明变量
        private type element;
        // 使用type做参数类型
        public void setsomething(type element){
            this element = element；
        }
        // 返回type类型变量
        public type getsomething(){
            return q;
        }
    }
    ```
3. 泛型局限性
   
    * 泛型类声明对象时定义了泛型，在整个类中有效。当明确了要操作的类型之后，所有方法要操作的`类型固定`了
    
4. 解决局限性(泛型方法)
    * 为了让不同方法可以操作不同的类型，且类型不确定，可以`将泛型定义在方法上`
    * 也可以在类上定义泛型，使用相同类型的方法直接使用该泛型；而使用不同类型的方法可以重新定义不同的泛型。
    * 泛型方法格式：`public <type> void method(){}`
    * 不能使用类型特有方法（如泛型指代一个对象，不能使用该泛型调用该对象的特有方法）

5. 静态方法泛型
   
* 静态方法不可以访问类上定义的泛型（泛型在创建对象时才存在），只能定义在方法上
  
6. 泛型接口
    * 在实现时，可以确定使用的数据类型
    * 实现接口时，实现类也可以定义为泛型

## 泛型限定
1. `?`通配符
    * 表示不确定的类型，用于占位；
    * 不能操作并接收类型

2. 向上泛型限定
    * 格式：`? extends father`
    * 表示可以接收father类型或者father的子类型

3. 向下泛型限定
    * 格式：`? super son`
    * 表示可以接收son类型或者son的父类型

