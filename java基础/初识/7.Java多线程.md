## 线程
1. 进程定义
    * 是一个正在运行中的程序
    * CPU在某一时刻只能执行某一个程序
    * 一个进程可以有多个执行路径，每条路径称为一个线程

2. 线程定义
    * 线程是进程中的执行路径或控制单元，是进程执行过程中的一种执行顺序
    * 线程是进程中独立的控制单元，控制着进程的执行顺序
    * 一个进程中至少有一个线程（由jvm创建，称之为主线程），当同时存在多个线程时，称之为多线程。

3. 多线程存在意义
    * 可以使多个代码同时运行，可以提高效率等。

4. 创建线程
    * 方法一（多个对象）
        1. 将类声明为`thread`的子类。
        2. 需要重写thread类的`run`方法（定义新线程要运行的代码）
        3. 使用该子类定义一个对象就意味着创建了一个线程。
        4. 使用对象调用`start()`方法可启动该线程，让jvm调用`run()`方法。
        5. jvm创建的主线程执行main方法中的代码`(即主线程要运行的代码存储在main方法中)`，自己开启的线程执行类中要运行的方法`(重写的run方法中的代码）`。
    * 方法二（一个对象）
        1. 声明并实现`Runnable接口`的类，并实现run方法
        2. 建立runnable接口的子类对象
        3. 通过Thread类建立线程对象，并将Runnable接口建立的子类对象作为参数传递给Thread类的构造函数。
        4. 调用线程对象的start方法开启线程，将调用Runnable接口子类的run方法

    * 实现方式和继承方式的区别
        1. 实现方法（常用，好用）：避免了单继承的局限性，将类中资源独立于各个线程。
        2. 线程代码存放位置不同：继承方式存放在子类的run方法中；实现方式代码存放在接口的子类的run方法中

5. 多线程的特性
    * 随机性（谁抢到，谁执行）
        1. 多线程时，每个线程都在获取CPU的执行权
        2. 而某一时刻，只有一个程序在运行（多核除外）
        3. CPU在多个进行间，每个进程的线程间做着快速切换，以达到表面同时运行的效果。
    * `局部的变量在每一个线程的区域中都有独立的一份软链接`
        1. 举例说明：若run方法中使用了for循环，则每一个线程对象都将独立的运行完每一层循环，而不是共同运行完这个for循环。（可以使用使用静态定义变量或使用第二种方法创建线程）

6. run和start的特点
    * run方法用于存储线程要运行的代码(main放存放主线程运行代码)
    * start方法，启动线程并运行run方法中存放的代码。

7. 线程运行状态
    * 被创建
        1. 线程被创建但是没有使用`start()`方法启动
    * 运行状态
        1. 线程具备执行资格，同时具有执行权
    * 冻结状态
        1. 线程放弃了CPU的执行权
        2. 运行状态使用`sleep()`或`wait()`方法进入
        3. sleep()在超过时间后被自动唤醒，wait()需要使用`notify()`方法主动唤醒
    * 临时阻塞状态
        1. 线程具备执行资格，但是没有CPU执行权
        2. 冻结状态被唤醒之后，没有执行权则进入阻塞
        3. 获取执行权后进入运行状态
    * 消亡状态
        1. 使用命令`stop()`或`run()`方法中代码执行完毕后线程消亡。

8. 获取线程对象及名称
    * 线程默认名称：Thread-编号
    * `Thread.currentThread()`:获取当前线程对象（即this指向的线程对象）
    * `getName()`:获取线程名称
    * 设置线程名称：setname或者构造函数（直接在调用父类构造函数即可）

9. **多线程的安全问题**
    * 问题原因：多线程中的共享数据需要涉及多条语句时，一个线程对多条语句只执行了一部分，这时另一个线程参与进来执行。则导致共享数据的错误。
    * 解决方法：Java对多线程的安全问题提供了专业的解决方式，即`同步代码块`
    * `同步代码块`(应用了锁机制)
        ```
        synchronized(对象){
            // 添加了锁（任意对象参数，建议使用Object类），线程进入后需要判断锁的状态，允许进入，更改锁的状态为禁止，运行完代码后，更改锁的状态为允许，等待下一个线程进入。
            需要被同步的代码块(即操作共享数据的语句)
        }
        ```
    * 同步的前提
        1. 必须要有两个或两个以上的线程
        2. 必须是多个线程使用同一个锁
    * 同步的优缺点
        1. 优点：解决了多线程的安全问题
        2. 确定：多个线程需要判断锁，较为消耗资源。
    * 寻找多线程安全问题
        1. 明确多线程运行代码
        2. 明确共享数据
        3. 明确多线程运行代码中操作共享数据的语句
        4. 明确共享数据是否涉及多条语句
    * 同步函数
        1. 把同步代码块的关键字`synchronized`作为修饰符添加到需要同步的代码的函数上。
        2. 可以把同步代码块中的代码封装成同步函数(更细颗粒度)
        3. 同步函数用的this（即本类对象）作为锁 
        4. 静态同步函数的锁是class对象（静态进内存时，内存中没有本类对象，只有该类的字节码文件对象---类名.class）

10. 多线程下的单例设计模式（懒汉式--不建议使用）
    * 多线程下存在安全隐患（对象作为共享数据，存在多条执行语句）
    * 可以使用双重判断的方式添加同步代码块

11. 死锁（同步后出现的弊端）
    *

## 线程间的通信
1. 特征认知
    * 以上所学多线程都同时运行一样的代码
    * 该段所学运行不同的代码，即需要有多个类
    * 线程间的通信，实际上就是多个线程用不同的方式操作同一个资源

2. 解决线程通信的安全问题
    * 使用同步解决安全问题
    * 注意两个前提条件：有两个线程；用同一个锁

3. 等待唤醒机制
    * 使用`锁标识.wait()`让线程放弃CPU执行权，进入冻结状态
    * 使用`锁标识.notify()`唤醒线程，唤醒线程池中最前面的线程
    * 该机制在于让多个线程根据资源状况依次执行。（不使用可能存在一个线程多次操作同一个资源的现象）
    * 等待唤醒语句要求线程必须是同一个锁（同步才存在锁）
    
4. 多个生产者和消费者情况
    * 该情况下，原先的等待唤醒方法失效
    * 解决：
        1. 循环判断标记
        2. 唤醒时，使用`notifyAll()`唤醒所有进程（达到一方等待后，能够唤醒对方线程的目的）
    * 使用新同步方法解决
5. **新同步方案（jdk5.0以上）**
    * 将`synchronized`替换成显式的`lock`操作
    * 将`Object类`中的`wait()\sleep()\notify()`等方法替换为`condition对象`,而后者可以使用lock锁在一个锁中绑定多个对象，便于本线程只唤醒对方的线程。
    * 注意释放锁的操作一定要执行，应该放在finally{}语句中。

## 停止线程
1. 注意
    * stop方法已经过时
    * 当线程进入冻结状态，即使循环结束也不会结束线程，可以使用`interrupt`方法使其回到运行状态。进而操作标记让线程结束。

2. 停止方案
    * 只有一种，当run方法执行结束则停止线程
    * 因此需要控制循环，便可以停止线程

## 线程中的补充部分
1. 守护线程
    * 用户线程：平时所创建的普通线程
    * 守护线程用于服务用户线程而创建

2. 守护线程注意事项
    * 使用`setDaemon(true)`方法声明，需要在线程开始前进行
    * 守护线程可以自动结束
    * 不能用于访问固有资源，如读写、计算等

3. join方法
    * 当A线程执行到了B线程的join方法：`B.join();`，A线程将进入等待，待B执行完后再执行。
    * 用于临时加入线程执行

4. 优先级和`yield方法`
    * 优先级表示抢到CPU执行权的几率
    * `yield`表示暂停当前正在执行的线程对象，可以减缓线程执行达到线程都有机会平均运行效果。
    
5. 开发中多线程常用书写方法(匿名对象，不用新建类)
    ```
    Runnable r = new Runnable()
    {
        public void run()
        {
            主体部分
        }
    }；
    new Thread(r).start();
    ```