# 反射机制

## 反射机制概述

1. **静态、动态语言对比**
   1. 动态语言：
      1. 运行时可以改变其结构的语言，如js
      2. 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 
   2. 静态语言：
      1. 运行时结构不可变
      2. 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 
2. **反射（reflection)概述**
   1. **Java反射是Java被视为动态（或准动态）语言的一个关键性质**
   2. 这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，并能直接任意对象的内部属性及方法
3. **反射原理**
   1. 类加载完之后，会在堆内存的方法区中，产生一个class类型的对象，这个对象包含了完整的类的结构信息。
   2. 通过class对象，可以让我们看到类的结构
   3. 这个对象就像一面镜子，通过镜子看到类的结构。所以称之为：反射
4. **反射的主要API**
   1. `class类`：代表一个类，一个类只有一个class对象
   2. `field类`：代表类的成员变量（类的属性）
   3. `method类`：代表类的方法
   4. `Constructor类`：代表类的构造方法
   5. `Array类`：提供了动态创建数组，以及访问数组的元素的静态方法
5. **反射的优缺点**
   1. 优点：可以实现动态创建对象和编译，灵活性更高
   2. 缺点：对性能有影响

## 获取反射对象

1. 通过`class`类可以获取到实体类的class对象

   ```java
   // 创建一个实体类
   class user {
       private String name;
       private int age;
   }
   public class testreflection{
       
   	public static void main(String[] args){
           // 通过反射获取类的class对象,一个实体类只能有一个class对象
           Class ref1 = Class.forname("实体类路径");
           
   }
   ```

2. **获取class类的三种方式**

   1. `Class.forname("实体类路径")`：
      1. 通过类的全类名获取
      2. 需要抛出异常
   2. `class ref = object.class`：
      1. 若已知具体的类，通过类的class属性获取，object指代一个实体类名
      2. 该方法最安全可靠，程序性能最高
   3. `class ref = example.getClass() `
      1. 通过一个类的实例，调用getClass()方法获取
      2. example指代一个类的实例

3. **各种类型的Class对象**

   1. 外部类、接口、数组、注解、枚举、基本数据类型、void等都有自己的class对象

## class对象

1. **Java内存**

   1. 堆

      * 存放新建的对象和数组

      * 可以被所有的线程共享

   2. 栈

      * 存放基本数据类型
      * 存放对象的引用（堆里面的地址）

   3. 方法区（特殊的堆）

      * 包含了所有的class和static变量
      * 可以被所有的线程共享

2. **类的加载过程**

   1. 类的加载：将类的class文件读入内存，并加载到方法区，为之创建一个`java.lang.class`对象（堆）
   2. 类的链接：**静态此时已产生**
      1. 验证加载的类信息符合JVM规范
      2. 为类变量（static）分配内存（方法区），并赋值
      3. 将虚拟机常量池的符号引用（常量名）替换为直接引用（地址）（**常量产生**）
   3. 初始化：由JVM负责对类初始化

## 使用

1. **获取类的运行时结构**

   ```Java
   /**
   *获取类的class对象，假设存在实体类user
   *通过该对象获取类的信息
   */
   class ref = user.class;
   //获取类名
   ref.getName(); // 获得全限定名
   ref.getSimpleName(); //获取类名
   
   //获取属性
   Field[] fields = ref.getFields();// 只能获取public权限的属性
   fields = ref.getDeclaredFields();// 获取所有属性
   
   // 获取指定属性的值
   Field name = ref.getDeclaredFields("name"); //获取指定的name属性的值
       
   // 获取类的方法
   Method[] methods = ref.getMethods(); // 获取本类及其父类的所有public权限方法
   methods = ref.getDeclaredMethods(); // 仅获取本类的所有方法
   Method getName = ref.getMethod("getName",参数类型.class); //获取指定getName方法
   
   // 获取构造器方法
   Constructor[] constructors = ref.getConstructor();// public
   // 所有
   // 指定
   ```

2. **动态创建对象执行方法**

   ```Java
   /**
   * 获取类的class对象
   * 通过class动态创建对象及其方法
   */
   // 实体类user
   /**@Data
   *@有参构造
   *@无参构造
   */
   class user {
       private String name;
       private int age;
   }
   class ref = user.class;
   
   /** 通过class方法创建一个对象,要求user存在无参构造
   *其本质就是调用了类的无参构造
   */
   user obj1 = (user)ref.newInstance();
   
   /*通过构造器创建一个对象*/
   //通过反射获取一个构造器
   Contructor ctu = ref.getDeclaredContructor(String.class,int.class);
   user obj2 = (user)ctu.newInstance("sinon",18);
   
   /*通过反射调用普通方法*/
   // 创建对象
   user obj3 = (user)ref.newInstance();
   // 通过反射获取方法
   Method setName = ref.getDeclaredMethod("setName",String.class);
   //启动该方法,invoke(对象，方法参数)
   setName.invoke(obj3,"sinon");
   
   /*通过反射操作属性*/
   // 创建对象
   user obj4 = (user)ref.newInstance();
   // 通过反射获取指定属性
   Field name = ref.getDeclaredField("name");
   // 不能直接操作私有属性，需要关闭程序的安全检测,关闭可以提高反射性能
   name.setAccessible(true);
   name.set(obj4,"sinon");
   
   ```

3. **反射获取泛型信息**

4. **反射操作注解**

   ```Java
   // 创建一个注解,作用于类
   @target(value={elementType.type)//指定注解可用的地方
   @retention(retentionpolicy.runtime//云行时
   @Interface table{
       String value();
   }
   // 创建一个注解，作用于字段
   @target(value={elementType.value)
   @retention(retentionpolicy.runtime
   @Interface tableId{
       String name();
       int id();
   }
   // 创建一个实体类,添加注解
   @table("db_user")           
   class uesr{
       //字段添加注解
       @tableId(name="user_id",id=1001)
       private int id;
       private String name;
       private int age;
   }
   public class testref{
       public static void main(String[] args){
           // 获取实体类的calss对象
           class ref = user.class;
           
           /*获取注解的值*/
           // 通过反射获取注解
           Annotation[] aots = ref.getAnnotations();
           // 获得注解@table的值
           table tab = (table)ref.getAnnotation(table.class);
           String value = tab.value();
           
           /*获取字段上的注解/指定注解*/
           // 通过反射获取指定属性
           Field fie = ref.getDeclaredField("id");
           // 获取属性的注解
           Annotation ano = fie.getAnnotation(tableId.class);
           // 通过注解获取值
           ano.id;
           ano.name;
       }
   }           
   ```

   

